# contains the def of a int list and some helper functions
# (similar to the python list)
pub type int_list { pub [] | [|](head:int, tail:int_list) }


pub def print(x:int_list) use !io {
    if { x = [ ?h | ?t] :: 
        !print(h)
        foreign c putchar(' ', !io)
        !print(t)
    }
}

pub def naive_reverse(lst: int_list, ?result: int_list) {
    if { lst = [ ?h | ?t] ::
        naive_reverse(t, ?rt)
        ?result = append(rt, h)
    | otherwise ::
        ?result = []
    }
}

pub def println(x:int_list) use !io {
    !print(x)
    !nl
}


# Returns an `int_list`, starting from `start`, and increments by `step`,
# and stops before `stop`
# XXX: The code below does not work due to issue: https://github.com/pschachte/wybe/issues/87
# pub def range(start:int, stop:int, step:int, ?result:int_list) {
#     ?result = []
#     do {
#         while start < stop
#         ?result = [start | result]
#         ?start = start + step
#     }
#     reverse(!result)
# }
pub def range(start:int, stop:int, step:int, ?result:int_list) {
    ?result = []
    range_loop(start, stop, step, !result)
    reverse(!result)
}

pub def range_loop(start:int, stop:int, step:int, !result:int_list) {
    if { start < stop ::
        ?result = [start | result]
        range_loop(start+step, stop, step, !result)
    }
}

# Add an item to the end of the list.
pub def append(lst:int_list, v: int):int_list = extend(lst, [v])


# Extend the first list by appending all the items from the second list.
pub def extend(lst1:int_list, lst2:int_list):int_list = 
    if lst1 = [?h | ?t] then [h | extend(t, lst2)] else lst2


# Insert an item at a given position.
pub def insert(lst:int_list, idx:int, v:int):int_list = 
    if idx = 0
    then
        [v | lst]
    else
        if lst = [?h | ?t]
        then
            [h | insert(t, idx-1, v)]
        else
            # list not long enough
            insert(lst, idx-1, v)


# Remove the first item from the list whose value is equal to v.
pub def remove(lst:int_list, v:int):int_list =
    if lst = [?h | ?t]
    then
        if h = v
        then
            t
        else
            [h | remove(t, v)]
    else
        []


# Remove the item at the given position in the list
pub def pop(lst:int_list, idx:int):int_list = 
    if lst = [?h | ?t]
    then
        if idx = 0
        then
            t
        else
            [h | pop(t, idx-1)]
    else
        []



# Return the number of times x appears in the list.
pub def count(lst:int_list, x:int):int =
    if lst = [?h | ?t]
    then
        count(t, x) + if h = x then 1 else 0
    else
        0


# Return zero-based index in the list of the first item whose value is equal to x.
pub def index(lst:int_list, x:int):int = index_helper(lst, 0, x)

def index_helper(lst:int_list, idx:int, x:int):int = 
    if lst = [?h | ?t]
    then
        if h = x
        then
            idx
        else
            index_helper(t, idx+1, x)
    else
        -1

# Sort the items of the list
pub def sort(!lst:int_list) {
    if { lst = [?h | ?t] ::
        partition(t, h, ?l, ?ge)
        sort(!l)
        sort(!ge)
        ?lst = extend(l, [h|ge])
    | otherwise ::
    }
}

# Partition the given list based on a given pivot value
def partition(lst:int_list, v:int, ?l:int_list, ?ge:int_list) {
    if { lst = [?h | ?t] ::
        partition(t, v, ?l, ?ge)
        if { h < v ::
            ?l = [h|l]
        | otherwise ::
            ?ge = [h|ge]
        }
    | otherwise ::
        ?l = []
        ?ge = []
    }
}

# Reverse the elements of the list.
pub def reverse(lst:int_list):int_list = reverse_helper(lst, [])

def reverse_helper(lst:int_list, acc:int_list):int_list =
    if lst = [?h | ?t] then reverse_helper(t, [h|acc]) else acc
