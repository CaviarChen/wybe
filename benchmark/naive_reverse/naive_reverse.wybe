pub type int_list { pub [] | [|](head:int, tail:int_list) }

pub def naive_reverse(lst: int_list, ?result: int_list) {
    if { lst = [ ?h | ?t] ::
        naive_reverse(t, ?rt)
        ?result = append(rt, h)
    | otherwise ::
        ?result = []
    }
}

# Add an item to the end of the list.
pub def append(lst:int_list, v: int):int_list = extend(lst, [v])

# Extend the first list by appending all the items from the second list.
pub def extend(lst1:int_list, lst2:int_list):int_list = 
    if lst1 = [?h | ?t] then [h | extend(t, lst2)] else lst2

pub def new_list(n:int, ?result:int_list) {
    ?result = []
    new_list_loop(n-1,!result)
}
pub def new_list_loop(n:int, !result:int_list) {
    if { n >= 0 ::
        ?result = [n | result]
        new_list_loop(n-1, !result)
    }
}

pub def print(x:int_list) use !io {
    if { x = [ ?h | ?t] :: 
        !print(h)
        foreign c putchar(' ', !io)
        !print(t)
    }
}
pub def println(x:int_list) use !io {
    !print(x)
    !nl
}

!print("=== malloc count before everything: ")
!print_malloc_count()

new_list(100000, ?lst)

!print("=== malloc count after creating list: ")
!print_malloc_count()

!println(lst)

naive_reverse(lst, ?lst)
!println(lst)

!print("=== malloc count after reverse: ")
!print_malloc_count()
