pragma no_standard_library  # Standard library can't depend on itself!

public type bool { public false | true
    # These are syntax errors because they are operators:
    public def and(p:bool, q:bool):bool = foreign llvm and(p,q)
    public def or(p:bool, q:bool):bool = foreign llvm or(p,q)
    public def not(p:bool):bool = foreign llvm xor(p,true)
    public def =(x:bool, y:bool):bool = foreign llvm icmp eq(x,y)
    public def /=(x:bool,y:bool):bool = foreign llvm icmp ne(x,y)
}


public type int is i64 {
    public def +(x:int,y:int):int = foreign llvm add(x,y)
    public def +(?x:int,y:int,z:int) { ?x = foreign llvm sub(z,y) }
    public def +(x:int,?y:int,z:int) { ?y = foreign llvm sub(z,x) }
    public def -(x:int,y:int):int = foreign llvm sub(x,y)
    public def -(?x:int,y:int,z:int) { ?x = foreign llvm add(z,y) }
    public def -(x:int,?y:int,z:int) { ?y = foreign llvm sub(z,x) }
    public def -(x:int):int = foreign llvm sub(0,x)
    public def -(?x:int,y:int) { ?x = foreign llvm sub(0,y) }
    public def *(x:int,y:int):int = foreign llvm mul(x,y)
    public def /(x:int,y:int):int = foreign llvm sdiv(x,y)
    public def /=(x:int,y:int):bool = foreign llvm icmp ne(x,y)
    public def <(x:int,y:int):bool = foreign llvm icmp slt(x,y)
    public def <=(x:int,y:int):bool = foreign llvm icmp sle(x,y)
    public def >(x:int,y:int):bool = foreign llvm icmp sgt(x,y)
    public def >=(x:int,y:int):bool = foreign llvm icmp sge(x,y)
    public def =(x:int, y:int):bool = foreign llvm icmp eq(x,y)
    public def sqrt(x:int):int = foreign C isqrt(x)
    public def power(x:int,y:int):int = foreign C ipow(x,y)
    public def incr(!x:int) { ?x = x + 1 }
    public def decr(!x:int) { ?x = x - 1 }
}


public type float is f64 {
    public def +(x:float,y:float):float = foreign llvm fadd(x,y)
    public def +(?x:float,y:float,z:float) { ?x = foreign llvm fsub(z,y) }
    public def +(x:float,?y:float,z:float) { ?y = foreign llvm fsub(z,x) }
    public def -(x:float,y:float):float = foreign llvm fsub(x,y)
    public def -(?x:float,y:float,z:float) { ?x = foreign llvm fadd(z,y) }
    public def -(x:float,?y:float,z:float) { ?y = foreign llvm fsub(z,x) }
    # public def -(x:float):float = foreign llvm fsub(0,x)
    # public def -(?x:float,y:float) { ?x = foreign llvm fsub(0,y) }
    public def *(x:float,y:float):float = foreign llvm fmul(x,y)
    public def /(x:float,y:float):float = foreign llvm fdiv(x,y)
    public def /=(x:float,y:float):bool = foreign llvm fcmp ne(x,y)
    public def <(x:float,y:float):bool = foreign llvm fcmp slt(x,y)
    public def <=(x:float,y:float):bool = foreign llvm fcmp sle(x,y)
    public def >(x:float,y:float):bool = foreign llvm fcmp sgt(x,y)
    public def >=(x:float,y:float):bool = foreign llvm fcmp sge(x,y)
    public def =(x:float, y:float):bool = foreign llvm fcmp eq(x,y)
    public def sqrt(x:float):float = foreign C sqrt(x)
    public def power(x:float,y:float):float = foreign C pow(x,y)
}


public type string is pointer8 {
    # this whole implementation is completely wrong, but will do for now
    #wrong: public def ++(x:string, y:string):string = foreign c strcat(x,y)
    public def =(x:string, y:string):bool  = foreign c strcmp(x,y) = 0
    public def /=(x:string,y:string):bool  = foreign c strcmp(x,y) /= 0
    public def <(x:string, y:string):bool  = foreign c strcmp(x,y) < 0
    public def <=(x:string, y:string):bool = foreign c strcmp(x,y) <= 0
    public def >(x:string, y:string):bool  = foreign c strcmp(x,y) > 0
    public def >=(x:string, y:string):bool = foreign c strcmp(x,y) >= 0
}


public type char is i8 {
    public def =(x:char, y:char):bool = foreign llvm icmp eq(x,y)
    public def /=(x:char,y:char):bool = foreign llvm icmp ne(x,y)
}


public module io {
    public resource io:phantom = phantom

    public def nl use !io { foreign c putchar('\n', !io) }

    public def print(x:int) use !io { foreign c print_int(x, !io) }
    public def println(x:int) use !io { !print(x) !nl }
    # public def read(?x:int) use !io { foreign c read_int(?x,!io) }

    public def print(x:float) use !io { foreign c print_float(x,!io) }
    public def println(x:float) use !io { !print(x) !nl }
    # public def read(?x:float) use !io { foreign c read_float(?x,!io) }

    public def print(x:char) use !io { foreign c putchar(x,!io) }
    public def println(x:char) use !io { !print(x) !nl }
    public def read(?x:char) use !io { foreign c read_char(?x,!io) }

    public def print(x:string) use !io { foreign c print_string(x,!io) }
    public def println(x:string) use !io { !print(x) !nl }
    # public def read(?x:string) use !io { foreign c read_line(?x,!io) }

    public def print(x:bool) use !io {
       !print(if false(x) then "false" else "true")
    }
    public def println(x:bool) use !io { !print(x) !nl }
#    public def eof:char = foreign lpvm cast(-1)
}

public type phantom is phantom {
    # public def phantom:phantom = foreign lpvm cast(0)
    # public def =(x:phantom,?y:phantom) { ?y = foreign lpvm cast(0) }
    # public def =(?x:phantom,y:phantom) { ?x = foreign lpvm cast(0) }
}

# public module allocation {
#     use wybe.io
#     foreign c gc_init(!io)
# }


public module command_line {
    # The number of command line arguments.  This is automatically
    # initialised by the code that builds executables.
    public resource argc:int

    # The actual command line arguments. This is really a C array of
    # strings, but we don't support them yet, so I'm just calling it an int
    # for now. That means you can't actually get the arguments yet. This is
    # automatically initialised by the code that builds executables.
    public resource argv:int      # until we support C arrays

    # The exit code to return to the invoking shell.  This is initialised to
    # zero, so it only needs to be assigned for error cases.
    public resource exit_code:int # = 0 when we support resource initialisation

    # Set the exit code, but don't exit immediately.
    public def set_exit_code(code:int) use !exit_code {
        ?exit_code = code
    }
}
