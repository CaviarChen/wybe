======================================================================
AFTER EVERYTHING:
 Module type_list
  public submods  : 
  public types    : intlist: (type_list.intlist,"pointer")
  public resources: 
  public procs    : type_list.++<0>
                    type_list.intlist.=<0>
                    type_list.intlist.[]<0>
                    type_list.intlist.[|]<0>
                    type_list.intlist.[|]<1>
                    type_list.intlist.head<0>
                    type_list.intlist.head<1>
                    type_list.intlist.tail<0>
                    type_list.intlist.tail<1>
  imports         : public use type_list.intlist
                    use wybe
  types           : intlist/0 (pointer)  @type_list:1:8
  resources       : 
  procs           : 

++ > public (1 calls)
0: ++(x#0:type_list.intlist, y#0:type_list.intlist, ?$#0:type_list.intlist):
    foreign lpvm cast(x#0:type_list.intlist, ?tmp$5#0:wybe.int)
    foreign llvm icmp ne(~tmp$5#0:wybe.int, 0:wybe.int, ?tmp$6#0:wybe.bool)
    case ~tmp$6#0:wybe.bool of
    0:
        foreign llvm move(~y#0:type_list.intlist, ?$#0:type_list.intlist) @type_list:3:8

    1:
        foreign lpvm access(x#0:type_list.intlist, 0:wybe.int, ?h#0:wybe.int)
        foreign lpvm access(~x#0:type_list.intlist, 8:wybe.int, ?t#0:type_list.intlist)
        type_list.++<0>(~t#0:type_list.intlist, ~y#0:type_list.intlist, ?tmp$2#0:type_list.intlist) @type_list:5:13
        foreign lpvm alloc(16:wybe.int, ?tmp$9#0:type_list.intlist)
        foreign lpvm mutate(~tmp$9#0:type_list.intlist, ?tmp$10#0:type_list.intlist, 0:wybe.int, ~h#0:wybe.int)
        foreign lpvm mutate(~tmp$10#0:type_list.intlist, ?$#0:type_list.intlist, 8:wybe.int, ~tmp$2#0:type_list.intlist)

  submodules      : type_list.intlist
--------------------------------------------------
 Module type_list.intlist([])
  public submods  : 
  public types    : 
  public resources: 
  public procs    : type_list.intlist.=<0>
                    type_list.intlist.[]<0>
                    type_list.intlist.[|]<0>
                    type_list.intlist.[|]<1>
                    type_list.intlist.head<0>
                    type_list.intlist.head<1>
                    type_list.intlist.tail<0>
                    type_list.intlist.tail<1>
  imports         : use type_list
                    use wybe
  types           : 
  resources       : 
  procs           : 

= > public test (3 calls)
0: =($left#0:type_list.intlist, $right#0:type_list.intlist, ?$$#0:wybe.bool):
    foreign lpvm cast($left#0:type_list.intlist, ?tmp$0#0:wybe.int)
    foreign llvm icmp eq(tmp$0#0:wybe.int, 0:wybe.int, ?tmp$1#0:wybe.bool)
    case ~tmp$1#0:wybe.bool of
    0:
        foreign llvm icmp ne(~tmp$0#0:wybe.int, 0:wybe.int, ?tmp$9#0:wybe.bool)
        case ~tmp$9#0:wybe.bool of
        0:
            foreign llvm move(0:wybe.bool, ?$$#0:wybe.bool)

        1:
            foreign lpvm access($left#0:type_list.intlist, 0:wybe.int, ?$left$head#0:wybe.int)
            foreign lpvm access(~$left#0:type_list.intlist, 8:wybe.int, ?$left$tail#0:type_list.intlist)
            foreign lpvm cast($right#0:type_list.intlist, ?tmp$11#0:wybe.int)
            foreign llvm icmp ne(~tmp$11#0:wybe.int, 0:wybe.int, ?tmp$12#0:wybe.bool)
            case ~tmp$12#0:wybe.bool of
            0:
                foreign llvm move(0:wybe.bool, ?$$#0:wybe.bool)

            1:
                foreign lpvm access($right#0:type_list.intlist, 0:wybe.int, ?$right$head#0:wybe.int)
                foreign lpvm access(~$right#0:type_list.intlist, 8:wybe.int, ?$right$tail#0:type_list.intlist)
                foreign llvm icmp eq(~$left$head#0:wybe.int, ~$right$head#0:wybe.int, ?tmp$5#0:wybe.bool) @wybe:27:40
                case ~tmp$5#0:wybe.bool of
                0:
                    foreign llvm move(0:wybe.bool, ?$$#0:wybe.bool)

                1:
                    type_list.intlist.=<0>(~$left$tail#0:type_list.intlist, ~$right$tail#0:type_list.intlist, ?$$#0:wybe.bool)




    1:
        foreign llvm icmp eq(~$left#0:wybe.int, ~$right#0:wybe.int, ?$$#0:wybe.bool)



[] > public inline (0 calls)
0: [](?$#0:type_list.intlist):
    foreign lpvm cast(0:type_list.intlist, ?$#0:type_list.intlist)


[|] > public inline (0 calls)
0: [|](head#0:wybe.int, tail#0:type_list.intlist, ?$#0:type_list.intlist):
    foreign lpvm alloc(16:wybe.int, ?$rec#0:type_list.intlist)
    foreign lpvm mutate(~%$rec#0:type_list.intlist, ?%$rec#1:type_list.intlist, 0:wybe.int, ~head#0:wybe.int)
    foreign lpvm mutate(~%$rec#1:type_list.intlist, ?%$#0:type_list.intlist, 8:wybe.int, ~tail#0:type_list.intlist)
[|] > public inline test (7 calls)
1: [|](?head#0:wybe.int, ?tail#0:type_list.intlist, $#0:type_list.intlist, ?$$#0:wybe.bool):
    foreign lpvm cast($#0:type_list.intlist, ?tmp$0#0:wybe.int)
    foreign llvm icmp ne(~tmp$0#0:wybe.int, 0:wybe.int, ?tmp$1#0:wybe.bool)
    case ~tmp$1#0:wybe.bool of
    0:
        foreign llvm move(0:wybe.bool, ?$$#0:wybe.bool)

    1:
        foreign lpvm access($#0:type_list.intlist, 0:wybe.int, ?head#0:wybe.int)
        foreign lpvm access(~$#0:type_list.intlist, 8:wybe.int, ?tail#0:type_list.intlist)
        foreign llvm move(1:wybe.bool, ?$$#0:wybe.bool)



head > public inline test (0 calls)
0: head($rec#0:type_list.intlist, ?$#0:wybe.int, ?$$#0:wybe.bool):
    foreign lpvm cast($rec#0:type_list.intlist, ?tmp$0#0:wybe.int)
    foreign llvm icmp ne(~tmp$0#0:wybe.int, 0:wybe.int, ?tmp$1#0:wybe.bool)
    case ~tmp$1#0:wybe.bool of
    0:
        foreign llvm move(0:wybe.bool, ?$$#0:wybe.bool)

    1:
        foreign lpvm access(~$rec#0:type_list.intlist, 0:wybe.int, ?$#0:wybe.int)
        foreign llvm move(1:wybe.bool, ?$$#0:wybe.bool)

head > public inline test (0 calls)
1: head($rec#0:type_list.intlist, ?$rec#1:type_list.intlist, $field#0:wybe.int, ?$$#0:wybe.bool):
    foreign lpvm cast($rec#0:type_list.intlist, ?tmp$0#0:wybe.int)
    foreign llvm icmp ne(~tmp$0#0:wybe.int, 0:wybe.int, ?tmp$1#0:wybe.bool)
    case ~tmp$1#0:wybe.bool of
    0:
        foreign llvm move(0:wybe.bool, ?$$#0:wybe.bool)
        foreign llvm move(~$rec#0:type_list.intlist, ?$rec#1:type_list.intlist)

    1:
        foreign lpvm mutate(~%$rec#0:type_list.intlist, ?%$rec#1:type_list.intlist, 0:wybe.int, ~$field#0:wybe.int)
        foreign llvm move(1:wybe.bool, ?$$#0:wybe.bool)



tail > public inline test (0 calls)
0: tail($rec#0:type_list.intlist, ?$#0:type_list.intlist, ?$$#0:wybe.bool):
    foreign lpvm cast($rec#0:type_list.intlist, ?tmp$0#0:wybe.int)
    foreign llvm icmp ne(~tmp$0#0:wybe.int, 0:wybe.int, ?tmp$1#0:wybe.bool)
    case ~tmp$1#0:wybe.bool of
    0:
        foreign llvm move(0:wybe.bool, ?$$#0:wybe.bool)

    1:
        foreign lpvm access(~$rec#0:type_list.intlist, 8:wybe.int, ?$#0:type_list.intlist)
        foreign llvm move(1:wybe.bool, ?$$#0:wybe.bool)

tail > public inline test (0 calls)
1: tail($rec#0:type_list.intlist, ?$rec#1:type_list.intlist, $field#0:type_list.intlist, ?$$#0:wybe.bool):
    foreign lpvm cast($rec#0:type_list.intlist, ?tmp$0#0:wybe.int)
    foreign llvm icmp ne(~tmp$0#0:wybe.int, 0:wybe.int, ?tmp$1#0:wybe.bool)
    case ~tmp$1#0:wybe.bool of
    0:
        foreign llvm move(0:wybe.bool, ?$$#0:wybe.bool)
        foreign llvm move(~$rec#0:type_list.intlist, ?$rec#1:type_list.intlist)

    1:
        foreign lpvm mutate(~%$rec#0:type_list.intlist, ?%$rec#1:type_list.intlist, 8:wybe.int, ~$field#0:type_list.intlist)
        foreign llvm move(1:wybe.bool, ?$$#0:wybe.bool)

type_list, type_list.intlist
======================================================================
AFTER LLVM IR:

; ModuleID = 'type_list'
source_filename = "test-cases/type_list.wybe"

declare i8* @wybe_malloc(i32) local_unnamed_addr

define i64* @"type_list.++<0>"(i64* readonly, i64* %"y#0") local_unnamed_addr {
entry:
  %"tmp$6#0" = icmp eq i64* %0, null
  br i1 %"tmp$6#0", label %if.else, label %if.then

if.then:                                          ; preds = %entry
  %1 = load i64, i64* %0, align 4
  %2 = getelementptr i64, i64* %0, i64 1
  %3 = bitcast i64* %2 to i64**
  %4 = load i64*, i64** %3, align 8
  %"tmp$2#0" = tail call i64* @"type_list.++<0>"(i64* %4, i64* %"y#0")
  %5 = tail call i8* @wybe_malloc(i32 16)
  %6 = bitcast i8* %5 to i64*
  store i64 %1, i64* %6, align 4
  %7 = getelementptr i8, i8* %5, i64 8
  %8 = bitcast i8* %7 to i64**
  store i64* %"tmp$2#0", i64** %8, align 8
  ret i64* %6

if.else:                                          ; preds = %entry
  ret i64* %"y#0"
}

; Function Attrs: nounwind readonly
define i1 @"type_list.intlist.=<0>"(i64* readonly, i64* readonly) local_unnamed_addr #0 {
entry:
  %"tmp$1#05" = icmp eq i64* %0, null
  br i1 %"tmp$1#05", label %if.then, label %if.then1.preheader

if.then1.preheader:                               ; preds = %entry
  br label %if.then1

if.then:                                          ; preds = %if.then3, %entry
  %.tr2.lcssa = phi i64* [ %1, %entry ], [ %9, %if.then3 ]
  %"$$#0" = icmp eq i64* %.tr2.lcssa, null
  ret i1 %"$$#0"

if.then1:                                         ; preds = %if.then1.preheader, %if.then3
  %.tr27 = phi i64* [ %9, %if.then3 ], [ %1, %if.then1.preheader ]
  %.tr6 = phi i64* [ %4, %if.then3 ], [ %0, %if.then1.preheader ]
  %2 = getelementptr i64, i64* %.tr6, i64 1
  %3 = bitcast i64* %2 to i64**
  %4 = load i64*, i64** %3, align 8
  %"tmp$12#0" = icmp eq i64* %.tr27, null
  br i1 %"tmp$12#0", label %if.else2, label %if.then2

if.then2:                                         ; preds = %if.then1
  %5 = load i64, i64* %.tr6, align 4
  %6 = load i64, i64* %.tr27, align 4
  %"tmp$5#0" = icmp eq i64 %5, %6
  br i1 %"tmp$5#0", label %if.then3, label %if.else2

if.else2:                                         ; preds = %if.then1, %if.then2
  ret i1 false

if.then3:                                         ; preds = %if.then2
  %7 = getelementptr i64, i64* %.tr27, i64 1
  %8 = bitcast i64* %7 to i64**
  %9 = load i64*, i64** %8, align 8
  %"tmp$1#0" = icmp eq i64* %4, null
  br i1 %"tmp$1#0", label %if.then, label %if.then1
}

; Function Attrs: norecurse nounwind readnone
define noalias i64* @"type_list.intlist.[]<0>"() local_unnamed_addr #1 {
entry:
  ret i64* null
}

define i64* @"type_list.intlist.[|]<0>"(i64 %"head#0", i64* %"tail#0") local_unnamed_addr {
entry:
  %0 = tail call i8* @wybe_malloc(i32 16)
  %1 = bitcast i8* %0 to i64*
  store i64 %"head#0", i64* %1, align 4
  %2 = getelementptr i8, i8* %0, i64 8
  %3 = bitcast i8* %2 to i64**
  store i64* %"tail#0", i64** %3, align 8
  ret i64* %1
}

; Function Attrs: norecurse nounwind readnone
define { i64, i64*, i1 } @"type_list.intlist.[|]<1>"(i64* readnone) local_unnamed_addr #1 {
entry:
  %"tmp$1#0" = icmp ne i64* %0, null
  ret i1 %"tmp$1#0"
}

; Function Attrs: norecurse nounwind readnone
define { i64, i1 } @"type_list.intlist.head<0>"(i64* readnone) local_unnamed_addr #1 {
entry:
  %"tmp$1#0" = icmp ne i64* %0, null
  ret i1 %"tmp$1#0"
}

; Function Attrs: norecurse nounwind
define { i64*, i1 } @"type_list.intlist.head<1>"(i64*, i64 %"$field#0") local_unnamed_addr #2 {
entry:
  %"tmp$1#0" = icmp eq i64* %0, null
  br i1 %"tmp$1#0", label %if.else, label %if.then

if.then:                                          ; preds = %entry
  store i64 %"$field#0", i64* %0, align 4
  ret i1 true

if.else:                                          ; preds = %entry
  ret i64* null
}

; Function Attrs: norecurse nounwind readnone
define { i64*, i1 } @"type_list.intlist.tail<0>"(i64* readnone %"$rec#0") local_unnamed_addr #1 {
entry:
  %"tmp$1#0" = icmp ne i64* %"$rec#0", null
  ret i1 %"tmp$1#0"
}

; Function Attrs: norecurse nounwind
define { i64*, i1 } @"type_list.intlist.tail<1>"(i64* %"$rec#0", i64* %"$field#0") local_unnamed_addr #2 {
entry:
  %"tmp$1#0" = icmp eq i64* %"$rec#0", null
  br i1 %"tmp$1#0", label %if.else, label %if.then

if.then:                                          ; preds = %entry
  %0 = getelementptr i64, i64* %"$rec#0", i64 1
  %1 = bitcast i64* %0 to i64**
  store i64* %"$field#0", i64** %1, align 8
  ret i1 true

if.else:                                          ; preds = %entry
  ret i64* null
}

attributes #0 = { nounwind readonly }
attributes #1 = { norecurse nounwind readnone }
attributes #2 = { norecurse nounwind }

--------------------------------------------------
; ModuleID = 'type_list.intlist'
source_filename = "test-cases"

declare i8* @wybe_malloc(i32) local_unnamed_addr

; Function Attrs: nounwind readonly
define i1 @"type_list.intlist.=<0>"(i64* readonly, i64* readonly) local_unnamed_addr #0 {
entry:
  %"tmp$1#05" = icmp eq i64* %0, null
  br i1 %"tmp$1#05", label %if.then, label %if.then1.preheader

if.then1.preheader:                               ; preds = %entry
  br label %if.then1

if.then:                                          ; preds = %if.then3, %entry
  %.tr2.lcssa = phi i64* [ %1, %entry ], [ %9, %if.then3 ]
  %"$$#0" = icmp eq i64* %.tr2.lcssa, null
  ret i1 %"$$#0"

if.then1:                                         ; preds = %if.then1.preheader, %if.then3
  %.tr27 = phi i64* [ %9, %if.then3 ], [ %1, %if.then1.preheader ]
  %.tr6 = phi i64* [ %4, %if.then3 ], [ %0, %if.then1.preheader ]
  %2 = getelementptr i64, i64* %.tr6, i64 1
  %3 = bitcast i64* %2 to i64**
  %4 = load i64*, i64** %3, align 8
  %"tmp$12#0" = icmp eq i64* %.tr27, null
  br i1 %"tmp$12#0", label %if.else2, label %if.then2

if.then2:                                         ; preds = %if.then1
  %5 = load i64, i64* %.tr6, align 4
  %6 = load i64, i64* %.tr27, align 4
  %"tmp$5#0" = icmp eq i64 %5, %6
  br i1 %"tmp$5#0", label %if.then3, label %if.else2

if.else2:                                         ; preds = %if.then1, %if.then2
  ret i1 false

if.then3:                                         ; preds = %if.then2
  %7 = getelementptr i64, i64* %.tr27, i64 1
  %8 = bitcast i64* %7 to i64**
  %9 = load i64*, i64** %8, align 8
  %"tmp$1#0" = icmp eq i64* %4, null
  br i1 %"tmp$1#0", label %if.then, label %if.then1
}

; Function Attrs: norecurse nounwind readnone
define noalias i64* @"type_list.intlist.[]<0>"() local_unnamed_addr #1 {
entry:
  ret i64* null
}

define i64* @"type_list.intlist.[|]<0>"(i64 %"head#0", i64* %"tail#0") local_unnamed_addr {
entry:
  %0 = tail call i8* @wybe_malloc(i32 16)
  %1 = bitcast i8* %0 to i64*
  store i64 %"head#0", i64* %1, align 4
  %2 = getelementptr i8, i8* %0, i64 8
  %3 = bitcast i8* %2 to i64**
  store i64* %"tail#0", i64** %3, align 8
  ret i64* %1
}

; Function Attrs: norecurse nounwind readnone
define { i64, i64*, i1 } @"type_list.intlist.[|]<1>"(i64* readnone) local_unnamed_addr #1 {
entry:
  %"tmp$1#0" = icmp ne i64* %0, null
  ret i1 %"tmp$1#0"
}

; Function Attrs: norecurse nounwind readnone
define { i64, i1 } @"type_list.intlist.head<0>"(i64* readnone) local_unnamed_addr #1 {
entry:
  %"tmp$1#0" = icmp ne i64* %0, null
  ret i1 %"tmp$1#0"
}

; Function Attrs: norecurse nounwind
define { i64*, i1 } @"type_list.intlist.head<1>"(i64*, i64 %"$field#0") local_unnamed_addr #2 {
entry:
  %"tmp$1#0" = icmp eq i64* %0, null
  br i1 %"tmp$1#0", label %if.else, label %if.then

if.then:                                          ; preds = %entry
  store i64 %"$field#0", i64* %0, align 4
  ret i1 true

if.else:                                          ; preds = %entry
  ret i64* null
}

; Function Attrs: norecurse nounwind readnone
define { i64*, i1 } @"type_list.intlist.tail<0>"(i64* readnone %"$rec#0") local_unnamed_addr #1 {
entry:
  %"tmp$1#0" = icmp ne i64* %"$rec#0", null
  ret i1 %"tmp$1#0"
}

; Function Attrs: norecurse nounwind
define { i64*, i1 } @"type_list.intlist.tail<1>"(i64* %"$rec#0", i64* %"$field#0") local_unnamed_addr #2 {
entry:
  %"tmp$1#0" = icmp eq i64* %"$rec#0", null
  br i1 %"tmp$1#0", label %if.else, label %if.then

if.then:                                          ; preds = %entry
  %0 = getelementptr i64, i64* %"$rec#0", i64 1
  %1 = bitcast i64* %0 to i64**
  store i64* %"$field#0", i64** %1, align 8
  ret i1 true

if.else:                                          ; preds = %entry
  ret i64* null
}

attributes #0 = { nounwind readonly }
attributes #1 = { norecurse nounwind readnone }
attributes #2 = { norecurse nounwind }

