======================================================================
AFTER EVERYTHING:
 Module type_list
  public submods  : 
  public types    : intlist: (type_list.intlist,"pointer")
  public resources: 
  public procs    : type_list.++<0>
                    type_list.intlist.=<0>
                    type_list.intlist.[]<0>
                    type_list.intlist.[|]<0>
                    type_list.intlist.[|]<1>
                    type_list.intlist.head<0>
                    type_list.intlist.head<1>
                    type_list.intlist.tail<0>
                    type_list.intlist.tail<1>
  imports         : public use type_list.intlist
                    use wybe
  types           : intlist/0 (pointer)  @type_list:1:8
  resources       : 
  submodules      : type_list.intlist
  procs           : 

++ > public (1 calls)
0: ++(x#0:type_list.intlist, y#0:type_list.intlist, ?$#0:type_list.intlist):
    foreign lpvm cast(x#0:type_list.intlist, ?tmp$5#0:wybe.int)
    foreign llvm icmp ne(~tmp$5#0:wybe.int, 0:wybe.int, ?tmp$6#0:wybe.bool)
    case ~tmp$6#0:wybe.bool of
    0:
        foreign llvm move(~y#0:type_list.intlist, ?$#0:type_list.intlist) @type_list:3:8

    1:
        foreign lpvm access(x#0:type_list.intlist, 0:wybe.int, ?h#0:wybe.int)
        foreign lpvm access(~x#0:type_list.intlist, 8:wybe.int, ?t#0:type_list.intlist)
        type_list.++<0>(~t#0:type_list.intlist, ~y#0:type_list.intlist, ?tmp$2#0:type_list.intlist) @type_list:5:13
        foreign lpvm alloc(16:wybe.int, ?tmp$9#0:type_list.intlist)
        foreign lpvm mutate(~tmp$9#0:type_list.intlist, ?tmp$10#0:type_list.intlist, 0:wybe.int, ~h#0:wybe.int)
        foreign lpvm mutate(~tmp$10#0:type_list.intlist, ?$#0:type_list.intlist, 8:wybe.int, ~tmp$2#0:type_list.intlist)


  LLVM code       :

; ModuleID = 'type_list'


declare external ccc i8* @wybe_malloc(i32)

define external ccc i64* @"type_list.++<0>"(i64* %"x#0", i64* %"y#0"){
entry:
  %1 = ptrtoint i64* %"x#0" to i64
  %"tmp$6#0" = icmp ne i64 %1, 0
  br i1 %"tmp$6#0", label %if.then, label %if.else
if.then:
  %2 = bitcast i64* %"x#0" to i64*
  %3 = getelementptr i64, i64* %2, i64 0
  %4 = load i64, i64* %3
  %5 = bitcast i64* %"x#0" to i64**
  %6 = getelementptr i64*, i64** %5, i64 1
  %7 = load i64*, i64** %6
  %8 = inttoptr i64* %7 to i64*
  %"tmp$2#0" = tail call ccc i64* @"type_list.++<0>"(i64* %8, i64* %"y#0")
  %9 = tail call ccc i8* @wybe_malloc(i32 16)
  %10 = bitcast i8* %9 to i64*
  %11 = bitcast i64* %10 to i64*
  %12 = getelementptr i64, i64* %11, i64 0
  store i64 %4, i64* %12
  %13 = bitcast i64* %10 to i64**
  %14 = getelementptr i64*, i64** %13, i64 1
  store i64* %"tmp$2#0", i64** %14
  ret i64* %10
if.else:
  ret i64* %"y#0"
}
--------------------------------------------------
 Module type_list.intlist([])
  public submods  : 
  public types    : 
  public resources: 
  public procs    : type_list.intlist.=<0>
                    type_list.intlist.[]<0>
                    type_list.intlist.[|]<0>
                    type_list.intlist.[|]<1>
                    type_list.intlist.head<0>
                    type_list.intlist.head<1>
                    type_list.intlist.tail<0>
                    type_list.intlist.tail<1>
  imports         : use type_list
                    use wybe
  types           : 
  resources       : 
  procs           : 

= > public test (3 calls)
0: =($left#0:type_list.intlist, $right#0:type_list.intlist, ?$$#0:wybe.bool):
    foreign lpvm cast($left#0:type_list.intlist, ?tmp$0#0:wybe.int)
    foreign llvm icmp eq(tmp$0#0:wybe.int, 0:wybe.int, ?tmp$1#0:wybe.bool)
    case ~tmp$1#0:wybe.bool of
    0:
        foreign llvm icmp ne(~tmp$0#0:wybe.int, 0:wybe.int, ?tmp$9#0:wybe.bool)
        case ~tmp$9#0:wybe.bool of
        0:
            foreign llvm move(0:wybe.bool, ?$$#0:wybe.bool)

        1:
            foreign lpvm access($left#0:type_list.intlist, 0:wybe.int, ?$left$head#0:wybe.int)
            foreign lpvm access(~$left#0:type_list.intlist, 8:wybe.int, ?$left$tail#0:type_list.intlist)
            foreign lpvm cast($right#0:type_list.intlist, ?tmp$11#0:wybe.int)
            foreign llvm icmp ne(~tmp$11#0:wybe.int, 0:wybe.int, ?tmp$12#0:wybe.bool)
            case ~tmp$12#0:wybe.bool of
            0:
                foreign llvm move(0:wybe.bool, ?$$#0:wybe.bool)

            1:
                foreign lpvm access($right#0:type_list.intlist, 0:wybe.int, ?$right$head#0:wybe.int)
                foreign lpvm access(~$right#0:type_list.intlist, 8:wybe.int, ?$right$tail#0:type_list.intlist)
                foreign llvm icmp eq(~$left$head#0:wybe.int, ~$right$head#0:wybe.int, ?tmp$5#0:wybe.bool) @wybe:nn:nn
                case ~tmp$5#0:wybe.bool of
                0:
                    foreign llvm move(0:wybe.bool, ?$$#0:wybe.bool)

                1:
                    type_list.intlist.=<0>(~$left$tail#0:type_list.intlist, ~$right$tail#0:type_list.intlist, ?$$#0:wybe.bool)




    1:
        foreign llvm icmp eq(~$left#0:wybe.int, ~$right#0:wybe.int, ?$$#0:wybe.bool)



[] > public inline (0 calls)
0: [](?$#0:type_list.intlist):
    foreign llvm move(0:type_list.intlist, ?$#0:type_list.intlist)


[|] > public inline (0 calls)
0: [|](head#0:wybe.int, tail#0:type_list.intlist, ?$#0:type_list.intlist):
    foreign lpvm alloc(16:wybe.int, ?$rec#0:type_list.intlist)
    foreign lpvm mutate(~%$rec#0:type_list.intlist, ?%$rec#1:type_list.intlist, 0:wybe.int, ~head#0:wybe.int)
    foreign lpvm mutate(~%$rec#1:type_list.intlist, ?%$#0:type_list.intlist, 8:wybe.int, ~tail#0:type_list.intlist)
[|] > public inline test (7 calls)
1: [|](?head#0:wybe.int, ?tail#0:type_list.intlist, $#0:type_list.intlist, ?$$#0:wybe.bool):
    foreign lpvm cast($#0:type_list.intlist, ?tmp$0#0:wybe.int)
    foreign llvm icmp ne(~tmp$0#0:wybe.int, 0:wybe.int, ?tmp$1#0:wybe.bool)
    case ~tmp$1#0:wybe.bool of
    0:
        foreign llvm move(0:wybe.bool, ?$$#0:wybe.bool)

    1:
        foreign lpvm access($#0:type_list.intlist, 0:wybe.int, ?head#0:wybe.int)
        foreign lpvm access(~$#0:type_list.intlist, 8:wybe.int, ?tail#0:type_list.intlist)
        foreign llvm move(1:wybe.bool, ?$$#0:wybe.bool)



head > public inline test (0 calls)
0: head($rec#0:type_list.intlist, ?$#0:wybe.int, ?$$#0:wybe.bool):
    foreign lpvm cast($rec#0:type_list.intlist, ?tmp$0#0:wybe.int)
    foreign llvm icmp ne(~tmp$0#0:wybe.int, 0:wybe.int, ?tmp$1#0:wybe.bool)
    case ~tmp$1#0:wybe.bool of
    0:
        foreign llvm move(0:wybe.bool, ?$$#0:wybe.bool)

    1:
        foreign lpvm access(~$rec#0:type_list.intlist, 0:wybe.int, ?$#0:wybe.int)
        foreign llvm move(1:wybe.bool, ?$$#0:wybe.bool)

head > public inline test (0 calls)
1: head($rec#0:type_list.intlist, ?$rec#1:type_list.intlist, $field#0:wybe.int, ?$$#0:wybe.bool):
    foreign lpvm cast($rec#0:type_list.intlist, ?tmp$0#0:wybe.int)
    foreign llvm icmp ne(~tmp$0#0:wybe.int, 0:wybe.int, ?tmp$1#0:wybe.bool)
    case ~tmp$1#0:wybe.bool of
    0:
        foreign llvm move(0:wybe.bool, ?$$#0:wybe.bool)
        foreign llvm move(~$rec#0:type_list.intlist, ?$rec#1:type_list.intlist)

    1:
        foreign lpvm mutate(~%$rec#0:type_list.intlist, ?%$rec#1:type_list.intlist, 0:wybe.int, ~$field#0:wybe.int)
        foreign llvm move(1:wybe.bool, ?$$#0:wybe.bool)



tail > public inline test (0 calls)
0: tail($rec#0:type_list.intlist, ?$#0:type_list.intlist, ?$$#0:wybe.bool):
    foreign lpvm cast($rec#0:type_list.intlist, ?tmp$0#0:wybe.int)
    foreign llvm icmp ne(~tmp$0#0:wybe.int, 0:wybe.int, ?tmp$1#0:wybe.bool)
    case ~tmp$1#0:wybe.bool of
    0:
        foreign llvm move(0:wybe.bool, ?$$#0:wybe.bool)

    1:
        foreign lpvm access(~$rec#0:type_list.intlist, 8:wybe.int, ?$#0:type_list.intlist)
        foreign llvm move(1:wybe.bool, ?$$#0:wybe.bool)

tail > public inline test (0 calls)
1: tail($rec#0:type_list.intlist, ?$rec#1:type_list.intlist, $field#0:type_list.intlist, ?$$#0:wybe.bool):
    foreign lpvm cast($rec#0:type_list.intlist, ?tmp$0#0:wybe.int)
    foreign llvm icmp ne(~tmp$0#0:wybe.int, 0:wybe.int, ?tmp$1#0:wybe.bool)
    case ~tmp$1#0:wybe.bool of
    0:
        foreign llvm move(0:wybe.bool, ?$$#0:wybe.bool)
        foreign llvm move(~$rec#0:type_list.intlist, ?$rec#1:type_list.intlist)

    1:
        foreign lpvm mutate(~%$rec#0:type_list.intlist, ?%$rec#1:type_list.intlist, 8:wybe.int, ~$field#0:type_list.intlist)
        foreign llvm move(1:wybe.bool, ?$$#0:wybe.bool)


  LLVM code       :

; ModuleID = 'type_list.intlist'


declare external ccc i8* @wybe_malloc(i32)

define external ccc i1 @"type_list.intlist.=<0>"(i64* %"$left#0", i64* %"$right#0"){
entry:
  %1 = ptrtoint i64* %"$left#0" to i64
  %"tmp$1#0" = icmp eq i64 %1, 0
  br i1 %"tmp$1#0", label %if.then, label %if.else
if.then:
  %"$$#0" = icmp eq i64* %"$left#0", %"$right#0"
  ret i1 %"$$#0"
if.else:
  %"tmp$9#0" = icmp ne i64 %1, 0
  br i1 %"tmp$9#0", label %if.then1, label %if.else1
if.then1:
  %2 = bitcast i64* %"$left#0" to i64*
  %3 = getelementptr i64, i64* %2, i64 0
  %4 = load i64, i64* %3
  %5 = bitcast i64* %"$left#0" to i64**
  %6 = getelementptr i64*, i64** %5, i64 1
  %7 = load i64*, i64** %6
  %8 = inttoptr i64* %7 to i64*
  %9 = ptrtoint i64* %"$right#0" to i64
  %"tmp$12#0" = icmp ne i64 %9, 0
  br i1 %"tmp$12#0", label %if.then2, label %if.else2
if.else1:
  ret i1 %"tmp$9#0"
if.then2:
  %10 = bitcast i64* %"$right#0" to i64*
  %11 = getelementptr i64, i64* %10, i64 0
  %12 = load i64, i64* %11
  %13 = bitcast i64* %"$right#0" to i64**
  %14 = getelementptr i64*, i64** %13, i64 1
  %15 = load i64*, i64** %14
  %16 = inttoptr i64* %15 to i64*
  %"tmp$5#0" = icmp eq i64 %4, %12
  br i1 %"tmp$5#0", label %if.then3, label %if.else3
if.else2:
  ret i1 %"tmp$12#0"
if.then3:
  %"$$#0" = tail call ccc i1 @"type_list.intlist.=<0>"(i64* %8, i64* %16)
  ret i1 %"$$#0"
if.else3:
  ret i1 %"tmp$5#0"
}

define external ccc i64* @"type_list.intlist.[]<0>"(){
entry:
  ret i64 0
}

define external ccc i64* @"type_list.intlist.[|]<0>"(i64 %"head#0", i64* %"tail#0"){
entry:
  %17 = tail call ccc i8* @wybe_malloc(i32 16)
  %18 = bitcast i8* %17 to i64*
  %19 = bitcast i64* %18 to i64*
  %20 = getelementptr i64, i64* %19, i64 0
  store i64 %"head#0", i64* %20
  %21 = bitcast i64* %18 to i64**
  %22 = getelementptr i64*, i64** %21, i64 1
  store i64* %"tail#0", i64** %22
  ret i64* %18
}

define external ccc {i64, i64*, i1} @"type_list.intlist.[|]<1>"(i64* %"$#0"){
entry:
  %23 = ptrtoint i64* %"$#0" to i64
  %"tmp$1#0" = icmp ne i64 %23, 0
  br i1 %"tmp$1#0", label %if.then, label %if.else
if.then:
  %24 = bitcast i64* %"$#0" to i64*
  %25 = getelementptr i64, i64* %24, i64 0
  %26 = load i64, i64* %25
  %27 = bitcast i64* %"$#0" to i64**
  %28 = getelementptr i64*, i64** %27, i64 1
  %29 = load i64*, i64** %28
  %30 = inttoptr i64* %29 to i64*
  %31 = insertvalue {i64, i64*, i1} undef, i64 %26, 0
  %32 = insertvalue {i64, i64*, i1} %31, i64* %30, 1
  %33 = insertvalue {i64, i64*, i1} %32, i1 1, 2
  ret i1 1
if.else:
  %34 = insertvalue {i64, i64*, i1} undef, i64 %26, 0
  %35 = insertvalue {i64, i64*, i1} %34, i64* %30, 1
  %36 = insertvalue {i64, i64*, i1} %35, i1 0, 2
  ret i1 0
}

define external ccc {i64, i1} @"type_list.intlist.head<0>"(i64* %"$rec#0"){
entry:
  %37 = ptrtoint i64* %"$rec#0" to i64
  %"tmp$1#0" = icmp ne i64 %37, 0
  br i1 %"tmp$1#0", label %if.then, label %if.else
if.then:
  %38 = bitcast i64* %"$rec#0" to i64*
  %39 = getelementptr i64, i64* %38, i64 0
  %40 = load i64, i64* %39
  %41 = insertvalue {i64, i1} undef, i64 %40, 0
  %42 = insertvalue {i64, i1} %41, i1 1, 1
  ret i1 1
if.else:
  %43 = insertvalue {i64, i1} undef, i64 %40, 0
  %44 = insertvalue {i64, i1} %43, i1 0, 1
  ret i1 0
}

define external ccc {i64*, i1} @"type_list.intlist.head<1>"(i64* %"$rec#0", i64 %"$field#0"){
entry:
  %45 = ptrtoint i64* %"$rec#0" to i64
  %"tmp$1#0" = icmp ne i64 %45, 0
  br i1 %"tmp$1#0", label %if.then, label %if.else
if.then:
  %46 = bitcast i64* %"$rec#0" to i64*
  %47 = getelementptr i64, i64* %46, i64 0
  store i64 %"$field#0", i64* %47
  %48 = insertvalue {i64*, i1} undef, i64* %"$rec#0", 0
  %49 = insertvalue {i64*, i1} %48, i1 1, 1
  ret i1 1
if.else:
  %50 = insertvalue {i64*, i1} undef, i64* %"$rec#0", 0
  %51 = insertvalue {i64*, i1} %50, i1 0, 1
  ret i64* %"$rec#0"
}

define external ccc {i64*, i1} @"type_list.intlist.tail<0>"(i64* %"$rec#0"){
entry:
  %52 = ptrtoint i64* %"$rec#0" to i64
  %"tmp$1#0" = icmp ne i64 %52, 0
  br i1 %"tmp$1#0", label %if.then, label %if.else
if.then:
  %53 = bitcast i64* %"$rec#0" to i64**
  %54 = getelementptr i64*, i64** %53, i64 1
  %55 = load i64*, i64** %54
  %56 = inttoptr i64* %55 to i64*
  %57 = insertvalue {i64*, i1} undef, i64* %56, 0
  %58 = insertvalue {i64*, i1} %57, i1 1, 1
  ret i1 1
if.else:
  %59 = insertvalue {i64*, i1} undef, i64* %56, 0
  %60 = insertvalue {i64*, i1} %59, i1 0, 1
  ret i1 0
}

define external ccc {i64*, i1} @"type_list.intlist.tail<1>"(i64* %"$rec#0", i64* %"$field#0"){
entry:
  %61 = ptrtoint i64* %"$rec#0" to i64
  %"tmp$1#0" = icmp ne i64 %61, 0
  br i1 %"tmp$1#0", label %if.then, label %if.else
if.then:
  %62 = bitcast i64* %"$rec#0" to i64**
  %63 = getelementptr i64*, i64** %62, i64 1
  store i64* %"$field#0", i64** %63
  %64 = insertvalue {i64*, i1} undef, i64* %"$rec#0", 0
  %65 = insertvalue {i64*, i1} %64, i1 1, 1
  ret i1 1
if.else:
  %66 = insertvalue {i64*, i1} undef, i64* %"$rec#0", 0
  %67 = insertvalue {i64*, i1} %66, i1 0, 1
  ret i64* %"$rec#0"
}
