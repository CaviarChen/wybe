======================================================================
AFTER EVERYTHING:
 Module type_list
  public submods  : 
  public types    : intlist: (type_list.intlist,"pointer")
  public resources: 
  public procs    : type_list.++<0>
                    type_list.intlist.=<0>
                    type_list.intlist.=<1>
                    type_list.intlist.=<2>
                    type_list.intlist.[]<0>
                    type_list.intlist.[|]<0>
                    type_list.intlist.[|]<1>
                    type_list.intlist.head<0>
                    type_list.intlist.head<1>
                    type_list.intlist.tail<0>
                    type_list.intlist.tail<1>
  imports         : public use type_list.intlist
                    use wybe
  types           : intlist/0 (pointer)  @type_list:1:8
  resources       : 
  procs           : 

++ > public (1 calls)
0: ++(x#0:type_list.intlist, y#0:type_list.intlist, ?$#0:type_list.intlist):
    foreign lpvm cast(x#0:type_list.intlist, ?tmp$7#0:wybe.int)
    foreign llvm icmp ne(~tmp$7#0:wybe.int, 0:wybe.int, ?tmp$8#0:wybe.bool)
    case ~tmp$8#0:wybe.bool of
    0:
        foreign llvm move(~y#0:type_list.intlist, ?$#0:type_list.intlist) @type_list:3:8

    1:
        foreign lpvm access(x#0:type_list.intlist, 0:wybe.int, ?h#0:wybe.int)
        foreign lpvm access(~x#0:type_list.intlist, 8:wybe.int, ?t#0:type_list.intlist)
        type_list.++<0>(~t#0:type_list.intlist, ~y#0:type_list.intlist, ?tmp$3#0:type_list.intlist) @type_list:5:13
        foreign lpvm alloc(16:wybe.int, ?tmp$11#0:type_list.intlist)
        foreign lpvm mutate(~tmp$11#0:type_list.intlist, ?tmp$12#0:type_list.intlist, 0:wybe.int, ~h#0:wybe.int)
        foreign lpvm mutate(~tmp$12#0:type_list.intlist, ?$#0:type_list.intlist, 8:wybe.int, ~tmp$3#0:type_list.intlist)

  submodules      : type_list.intlist
--------------------------------------------------
 Module type_list.intlist([])
  public submods  : 
  public types    : 
  public resources: 
  public procs    : type_list.intlist.=<0>
                    type_list.intlist.=<1>
                    type_list.intlist.=<2>
                    type_list.intlist.[]<0>
                    type_list.intlist.[|]<0>
                    type_list.intlist.[|]<1>
                    type_list.intlist.head<0>
                    type_list.intlist.head<1>
                    type_list.intlist.tail<0>
                    type_list.intlist.tail<1>
  imports         : use wybe
  types           : 
  resources       : 
  procs           : 

= > public inline (0 calls)
0: =(?out#0:type_list.intlist, in#0:type_list.intlist):
    foreign llvm move(~in#0:type_list.intlist, ?out#0:type_list.intlist)
= > public inline (0 calls)
1: =(in#0:type_list.intlist, ?out#0:type_list.intlist):
    foreign llvm move(~in#0:type_list.intlist, ?out#0:type_list.intlist)
= > public test (3 calls)
2: =($left#0:type_list.intlist, $right#0:type_list.intlist, ?$$#0:wybe.bool):
    foreign lpvm cast($left#0:type_list.intlist, ?tmp$0#0:wybe.int)
    foreign llvm icmp eq(tmp$0#0:wybe.int, 0:wybe.int, ?tmp$1#0:wybe.bool)
    case ~tmp$1#0:wybe.bool of
    0:
        foreign llvm icmp ne(~tmp$0#0:wybe.int, 0:wybe.int, ?tmp$9#0:wybe.bool)
        case ~tmp$9#0:wybe.bool of
        0:
            foreign llvm move(0:wybe.bool, ?$$#0:wybe.bool)

        1:
            foreign lpvm access($left#0:type_list.intlist, 0:wybe.int, ?$left$head#0:wybe.int)
            foreign lpvm access(~$left#0:type_list.intlist, 8:wybe.int, ?$left$tail#0:type_list.intlist)
            foreign lpvm cast($right#0:type_list.intlist, ?tmp$11#0:wybe.int)
            foreign llvm icmp ne(~tmp$11#0:wybe.int, 0:wybe.int, ?tmp$12#0:wybe.bool)
            case ~tmp$12#0:wybe.bool of
            0:
                foreign llvm move(0:wybe.bool, ?$$#0:wybe.bool)

            1:
                foreign lpvm access($right#0:type_list.intlist, 0:wybe.int, ?$right$head#0:wybe.int)
                foreign lpvm access(~$right#0:type_list.intlist, 8:wybe.int, ?$right$tail#0:type_list.intlist)
                foreign llvm icmp eq(~$left$head#0:wybe.int, ~$right$head#0:wybe.int, ?tmp$5#0:wybe.bool) @wybe:28:40
                case ~tmp$5#0:wybe.bool of
                0:
                    foreign llvm move(0:wybe.bool, ?$$#0:wybe.bool)

                1:
                    type_list.intlist.=<2>(~$left$tail#0:type_list.intlist, ~$right$tail#0:type_list.intlist, ?$$#0:wybe.bool)




    1:
        foreign llvm icmp eq(~$left#0:wybe.int, ~$right#0:wybe.int, ?$$#0:wybe.bool)



[] > public inline (0 calls)
0: [](?$#0:type_list.intlist):
    foreign lpvm cast(0:type_list.intlist, ?$#0:type_list.intlist)


[|] > public inline (0 calls)
0: [|](head#0:wybe.int, tail#0:type_list.intlist, ?$#0:type_list.intlist):
    foreign lpvm alloc(16:wybe.int, ?$rec#0:type_list.intlist)
    foreign lpvm mutate(~%$rec#0:type_list.intlist, ?%$rec#1:type_list.intlist, 0:wybe.int, ~head#0:wybe.int)
    foreign lpvm mutate(~%$rec#1:type_list.intlist, ?%$#0:type_list.intlist, 8:wybe.int, ~tail#0:type_list.intlist)
[|] > public inline test (7 calls)
1: [|](?head#0:wybe.int, ?tail#0:type_list.intlist, $#0:type_list.intlist, ?$$#0:wybe.bool):
    foreign lpvm cast($#0:type_list.intlist, ?tmp$0#0:wybe.int)
    foreign llvm icmp ne(~tmp$0#0:wybe.int, 0:wybe.int, ?tmp$1#0:wybe.bool)
    case ~tmp$1#0:wybe.bool of
    0:
        foreign llvm move(0:wybe.bool, ?$$#0:wybe.bool)

    1:
        foreign lpvm access($#0:type_list.intlist, 0:wybe.int, ?head#0:wybe.int)
        foreign lpvm access(~$#0:type_list.intlist, 8:wybe.int, ?tail#0:type_list.intlist)
        foreign llvm move(1:wybe.bool, ?$$#0:wybe.bool)



head > public inline test (0 calls)
0: head($rec#0:type_list.intlist, ?$#0:wybe.int, ?$$#0:wybe.bool):
    foreign lpvm cast($rec#0:type_list.intlist, ?tmp$0#0:wybe.int)
    foreign llvm icmp ne(~tmp$0#0:wybe.int, 0:wybe.int, ?tmp$1#0:wybe.bool)
    case ~tmp$1#0:wybe.bool of
    0:
        foreign llvm move(0:wybe.bool, ?$$#0:wybe.bool)

    1:
        foreign lpvm access(~$rec#0:type_list.intlist, 0:wybe.int, ?$#0:wybe.int)
        foreign llvm move(1:wybe.bool, ?$$#0:wybe.bool)

head > public inline test (0 calls)
1: head($rec#0:type_list.intlist, ?$rec#1:type_list.intlist, $field#0:wybe.int, ?$$#0:wybe.bool):
    foreign lpvm cast($rec#0:type_list.intlist, ?tmp$0#0:wybe.int)
    foreign llvm icmp ne(~tmp$0#0:wybe.int, 0:wybe.int, ?tmp$1#0:wybe.bool)
    case ~tmp$1#0:wybe.bool of
    0:
        foreign llvm move(0:wybe.bool, ?$$#0:wybe.bool)
        foreign llvm move(~$rec#0:type_list.intlist, ?$rec#1:type_list.intlist)

    1:
        foreign lpvm mutate(~%$rec#0:type_list.intlist, ?%$rec#1:type_list.intlist, 0:wybe.int, ~$field#0:wybe.int)
        foreign llvm move(1:wybe.bool, ?$$#0:wybe.bool)



tail > public inline test (0 calls)
0: tail($rec#0:type_list.intlist, ?$#0:type_list.intlist, ?$$#0:wybe.bool):
    foreign lpvm cast($rec#0:type_list.intlist, ?tmp$0#0:wybe.int)
    foreign llvm icmp ne(~tmp$0#0:wybe.int, 0:wybe.int, ?tmp$1#0:wybe.bool)
    case ~tmp$1#0:wybe.bool of
    0:
        foreign llvm move(0:wybe.bool, ?$$#0:wybe.bool)

    1:
        foreign lpvm access(~$rec#0:type_list.intlist, 8:wybe.int, ?$#0:type_list.intlist)
        foreign llvm move(1:wybe.bool, ?$$#0:wybe.bool)

tail > public inline test (0 calls)
1: tail($rec#0:type_list.intlist, ?$rec#1:type_list.intlist, $field#0:type_list.intlist, ?$$#0:wybe.bool):
    foreign lpvm cast($rec#0:type_list.intlist, ?tmp$0#0:wybe.int)
    foreign llvm icmp ne(~tmp$0#0:wybe.int, 0:wybe.int, ?tmp$1#0:wybe.bool)
    case ~tmp$1#0:wybe.bool of
    0:
        foreign llvm move(0:wybe.bool, ?$$#0:wybe.bool)
        foreign llvm move(~$rec#0:type_list.intlist, ?$rec#1:type_list.intlist)

    1:
        foreign lpvm mutate(~%$rec#0:type_list.intlist, ?%$rec#1:type_list.intlist, 8:wybe.int, ~$field#0:type_list.intlist)
        foreign llvm move(1:wybe.bool, ?$$#0:wybe.bool)

type_list, type_list.intlist
======================================================================
AFTER LLVM IR:

; ModuleID = 'type_list'
source_filename = "test-cases/type_list.wybe"

declare i8* @wybe_malloc(i32) local_unnamed_addr

define i64* @"type_list.++<0>"(i64* readonly %"x#0", i64* %"y#0") local_unnamed_addr {
entry:
  %"tmp$8#0" = icmp eq i64* %"x#0", null
  br i1 %"tmp$8#0", label %if.else, label %if.then

if.then:                                          ; preds = %entry
  %0 = load i64, i64* %"x#0", align 4
  %1 = getelementptr i64, i64* %"x#0", i64 1
  %2 = bitcast i64* %1 to i64**
  %3 = load i64*, i64** %2, align 8
  %"tmp$3#0" = tail call i64* @"type_list.++<0>"(i64* %3, i64* %"y#0")
  %4 = tail call i8* @wybe_malloc(i32 16)
  %5 = bitcast i8* %4 to i64*
  store i64 %0, i64* %5, align 4
  %6 = getelementptr i8, i8* %4, i64 8
  %7 = bitcast i8* %6 to i64*
  %8 = ptrtoint i64* %"tmp$3#0" to i64
  store i64 %8, i64* %7, align 4
  ret i64* %5

if.else:                                          ; preds = %entry
  ret i64* %"y#0"
}

; Function Attrs: norecurse nounwind readnone
define i64* @"type_list.intlist.=<0>"(i64* readnone returned %"in#0") local_unnamed_addr #0 {
entry:
  ret i64* %"in#0"
}

; Function Attrs: norecurse nounwind readnone
define i64* @"type_list.intlist.=<1>"(i64* readnone returned %"in#0") local_unnamed_addr #0 {
entry:
  ret i64* %"in#0"
}

; Function Attrs: nounwind readonly
define i1 @"type_list.intlist.=<2>"(i64* readonly %"$left#0", i64* readonly %"$right#0") local_unnamed_addr #1 {
entry:
  %"tmp$1#04" = icmp eq i64* %"$left#0", null
  br i1 %"tmp$1#04", label %if.then, label %if.then1.preheader

if.then1.preheader:                               ; preds = %entry
  br label %if.then1

if.then:                                          ; preds = %if.then3, %entry
  %"$right#0.tr.lcssa" = phi i64* [ %"$right#0", %entry ], [ %7, %if.then3 ]
  %"$$#0" = icmp eq i64* %"$right#0.tr.lcssa", null
  ret i1 %"$$#0"

if.then1:                                         ; preds = %if.then1.preheader, %if.then3
  %"$right#0.tr6" = phi i64* [ %7, %if.then3 ], [ %"$right#0", %if.then1.preheader ]
  %"$left#0.tr5" = phi i64* [ %2, %if.then3 ], [ %"$left#0", %if.then1.preheader ]
  %0 = getelementptr i64, i64* %"$left#0.tr5", i64 1
  %1 = bitcast i64* %0 to i64**
  %2 = load i64*, i64** %1, align 8
  %"tmp$12#0" = icmp eq i64* %"$right#0.tr6", null
  br i1 %"tmp$12#0", label %if.else2, label %if.then2

if.then2:                                         ; preds = %if.then1
  %3 = load i64, i64* %"$left#0.tr5", align 4
  %4 = load i64, i64* %"$right#0.tr6", align 4
  %"tmp$5#0" = icmp eq i64 %3, %4
  br i1 %"tmp$5#0", label %if.then3, label %if.else2

if.else2:                                         ; preds = %if.then1, %if.then2
  ret i1 false

if.then3:                                         ; preds = %if.then2
  %5 = getelementptr i64, i64* %"$right#0.tr6", i64 1
  %6 = bitcast i64* %5 to i64**
  %7 = load i64*, i64** %6, align 8
  %"tmp$1#0" = icmp eq i64* %2, null
  br i1 %"tmp$1#0", label %if.then, label %if.then1
}

; Function Attrs: norecurse nounwind readnone
define noalias i64* @"type_list.intlist.[]<0>"() local_unnamed_addr #0 {
entry:
  ret i64* null
}

define i64* @"type_list.intlist.[|]<0>"(i64 %"head#0", i64* %"tail#0") local_unnamed_addr {
entry:
  %0 = tail call i8* @wybe_malloc(i32 16)
  %1 = bitcast i8* %0 to i64*
  store i64 %"head#0", i64* %1, align 4
  %2 = getelementptr i8, i8* %0, i64 8
  %3 = bitcast i8* %2 to i64*
  %4 = ptrtoint i64* %"tail#0" to i64
  store i64 %4, i64* %3, align 4
  ret i64* %1
}

; Function Attrs: norecurse nounwind readnone
define { i64, i64*, i1 } @"type_list.intlist.[|]<1>"(i64* readnone %"$#0") local_unnamed_addr #0 {
entry:
  %"tmp$1#0" = icmp ne i64* %"$#0", null
  ret i1 %"tmp$1#0"
}

; Function Attrs: norecurse nounwind readnone
define { i64, i1 } @"type_list.intlist.head<0>"(i64* readnone %"$rec#0") local_unnamed_addr #0 {
entry:
  %"tmp$1#0" = icmp ne i64* %"$rec#0", null
  ret i1 %"tmp$1#0"
}

; Function Attrs: norecurse nounwind
define { i64*, i1 } @"type_list.intlist.head<1>"(i64* %"$rec#0", i64 %"$field#0") local_unnamed_addr #2 {
entry:
  %"tmp$1#0" = icmp eq i64* %"$rec#0", null
  br i1 %"tmp$1#0", label %if.else, label %if.then

if.then:                                          ; preds = %entry
  store i64 %"$field#0", i64* %"$rec#0", align 4
  ret i1 true

if.else:                                          ; preds = %entry
  ret i64* null
}

; Function Attrs: norecurse nounwind readnone
define { i64*, i1 } @"type_list.intlist.tail<0>"(i64* readnone %"$rec#0") local_unnamed_addr #0 {
entry:
  %"tmp$1#0" = icmp ne i64* %"$rec#0", null
  ret i1 %"tmp$1#0"
}

; Function Attrs: norecurse nounwind
define { i64*, i1 } @"type_list.intlist.tail<1>"(i64* %"$rec#0", i64* %"$field#0") local_unnamed_addr #2 {
entry:
  %"tmp$1#0" = icmp eq i64* %"$rec#0", null
  br i1 %"tmp$1#0", label %if.else, label %if.then

if.then:                                          ; preds = %entry
  %0 = getelementptr i64, i64* %"$rec#0", i64 1
  %1 = ptrtoint i64* %"$field#0" to i64
  store i64 %1, i64* %0, align 4
  ret i1 true

if.else:                                          ; preds = %entry
  ret i64* null
}

attributes #0 = { norecurse nounwind readnone }
attributes #1 = { nounwind readonly }
attributes #2 = { norecurse nounwind }

--------------------------------------------------
; ModuleID = 'type_list.intlist'
source_filename = "test-cases"

declare i8* @wybe_malloc(i32) local_unnamed_addr

; Function Attrs: norecurse nounwind readnone
define i64* @"type_list.intlist.=<0>"(i64* readnone returned %"in#0") local_unnamed_addr #0 {
entry:
  ret i64* %"in#0"
}

; Function Attrs: norecurse nounwind readnone
define i64* @"type_list.intlist.=<1>"(i64* readnone returned %"in#0") local_unnamed_addr #0 {
entry:
  ret i64* %"in#0"
}

; Function Attrs: nounwind readonly
define i1 @"type_list.intlist.=<2>"(i64* readonly %"$left#0", i64* readonly %"$right#0") local_unnamed_addr #1 {
entry:
  %"tmp$1#04" = icmp eq i64* %"$left#0", null
  br i1 %"tmp$1#04", label %if.then, label %if.then1.preheader

if.then1.preheader:                               ; preds = %entry
  br label %if.then1

if.then:                                          ; preds = %if.then3, %entry
  %"$right#0.tr.lcssa" = phi i64* [ %"$right#0", %entry ], [ %7, %if.then3 ]
  %"$$#0" = icmp eq i64* %"$right#0.tr.lcssa", null
  ret i1 %"$$#0"

if.then1:                                         ; preds = %if.then1.preheader, %if.then3
  %"$right#0.tr6" = phi i64* [ %7, %if.then3 ], [ %"$right#0", %if.then1.preheader ]
  %"$left#0.tr5" = phi i64* [ %2, %if.then3 ], [ %"$left#0", %if.then1.preheader ]
  %0 = getelementptr i64, i64* %"$left#0.tr5", i64 1
  %1 = bitcast i64* %0 to i64**
  %2 = load i64*, i64** %1, align 8
  %"tmp$12#0" = icmp eq i64* %"$right#0.tr6", null
  br i1 %"tmp$12#0", label %if.else2, label %if.then2

if.then2:                                         ; preds = %if.then1
  %3 = load i64, i64* %"$left#0.tr5", align 4
  %4 = load i64, i64* %"$right#0.tr6", align 4
  %"tmp$5#0" = icmp eq i64 %3, %4
  br i1 %"tmp$5#0", label %if.then3, label %if.else2

if.else2:                                         ; preds = %if.then1, %if.then2
  ret i1 false

if.then3:                                         ; preds = %if.then2
  %5 = getelementptr i64, i64* %"$right#0.tr6", i64 1
  %6 = bitcast i64* %5 to i64**
  %7 = load i64*, i64** %6, align 8
  %"tmp$1#0" = icmp eq i64* %2, null
  br i1 %"tmp$1#0", label %if.then, label %if.then1
}

; Function Attrs: norecurse nounwind readnone
define noalias i64* @"type_list.intlist.[]<0>"() local_unnamed_addr #0 {
entry:
  ret i64* null
}

define i64* @"type_list.intlist.[|]<0>"(i64 %"head#0", i64* %"tail#0") local_unnamed_addr {
entry:
  %0 = tail call i8* @wybe_malloc(i32 16)
  %1 = bitcast i8* %0 to i64*
  store i64 %"head#0", i64* %1, align 4
  %2 = getelementptr i8, i8* %0, i64 8
  %3 = bitcast i8* %2 to i64*
  %4 = ptrtoint i64* %"tail#0" to i64
  store i64 %4, i64* %3, align 4
  ret i64* %1
}

; Function Attrs: norecurse nounwind readnone
define { i64, i64*, i1 } @"type_list.intlist.[|]<1>"(i64* readnone %"$#0") local_unnamed_addr #0 {
entry:
  %"tmp$1#0" = icmp ne i64* %"$#0", null
  ret i1 %"tmp$1#0"
}

; Function Attrs: norecurse nounwind readnone
define { i64, i1 } @"type_list.intlist.head<0>"(i64* readnone %"$rec#0") local_unnamed_addr #0 {
entry:
  %"tmp$1#0" = icmp ne i64* %"$rec#0", null
  ret i1 %"tmp$1#0"
}

; Function Attrs: norecurse nounwind
define { i64*, i1 } @"type_list.intlist.head<1>"(i64* %"$rec#0", i64 %"$field#0") local_unnamed_addr #2 {
entry:
  %"tmp$1#0" = icmp eq i64* %"$rec#0", null
  br i1 %"tmp$1#0", label %if.else, label %if.then

if.then:                                          ; preds = %entry
  store i64 %"$field#0", i64* %"$rec#0", align 4
  ret i1 true

if.else:                                          ; preds = %entry
  ret i64* null
}

; Function Attrs: norecurse nounwind readnone
define { i64*, i1 } @"type_list.intlist.tail<0>"(i64* readnone %"$rec#0") local_unnamed_addr #0 {
entry:
  %"tmp$1#0" = icmp ne i64* %"$rec#0", null
  ret i1 %"tmp$1#0"
}

; Function Attrs: norecurse nounwind
define { i64*, i1 } @"type_list.intlist.tail<1>"(i64* %"$rec#0", i64* %"$field#0") local_unnamed_addr #2 {
entry:
  %"tmp$1#0" = icmp eq i64* %"$rec#0", null
  br i1 %"tmp$1#0", label %if.else, label %if.then

if.then:                                          ; preds = %entry
  %0 = getelementptr i64, i64* %"$rec#0", i64 1
  %1 = ptrtoint i64* %"$field#0" to i64
  store i64 %1, i64* %0, align 4
  ret i1 true

if.else:                                          ; preds = %entry
  ret i64* null
}

attributes #0 = { norecurse nounwind readnone }
attributes #1 = { nounwind readonly }
attributes #2 = { norecurse nounwind }

