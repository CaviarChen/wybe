======================================================================
AFTER EVERYTHING:
 Module multictr
  public submods  : 
  public types    : number: (multictr.number,"pointer")
                    simple: (multictr.simple,"pointer")
  public resources: 
  public procs    : multictr.number.=<0>
                    multictr.number.=<1>
                    multictr.number.=<2>
                    multictr.number.float<0>
                    multictr.number.float<1>
                    multictr.number.float_value<0>
                    multictr.number.float_value<1>
                    multictr.number.int<0>
                    multictr.number.int<1>
                    multictr.number.int_value<0>
                    multictr.number.int_value<1>
                    multictr.simple.=<0>
                    multictr.simple.=<1>
                    multictr.simple.=<2>
                    multictr.simple.one<0>
                    multictr.simple.one<1>
                    multictr.simple.one_field<0>
                    multictr.simple.one_field<1>
                    multictr.simple.two<0>
                    multictr.simple.two<1>
                    multictr.simple.two_field<0>
                    multictr.simple.two_field<1>
                    multictr.simple.zero<0>
  imports         : public use multictr.number
                    public use multictr.simple
                    use wybe
  types           : number/0 (pointer)  @multictr:3:8, simple/0 (pointer)  @multictr:8:8
  resources       : 
  procs           : 

  submodules      : multictr.number, multictr.simple
--------------------------------------------------
 Module multictr.number([])
  public submods  : 
  public types    : 
  public resources: 
  public procs    : multictr.number.=<0>
                    multictr.number.=<1>
                    multictr.number.=<2>
                    multictr.number.float<0>
                    multictr.number.float<1>
                    multictr.number.float_value<0>
                    multictr.number.float_value<1>
                    multictr.number.int<0>
                    multictr.number.int<1>
                    multictr.number.int_value<0>
                    multictr.number.int_value<1>
  imports         : use wybe
  types           : 
  resources       : 
  procs           : 

= > public inline (0 calls)
0: =(?out#0:multictr.number, in#0:multictr.number): Alias Pairs: []

    foreign llvm move(~in#0:multictr.number, ?out#0:multictr.number)
= > public inline (0 calls)
1: =(in#0:multictr.number, ?out#0:multictr.number): Alias Pairs: []

    foreign llvm move(~in#0:multictr.number, ?out#0:multictr.number)
= > public test (2 calls)
2: =($left#0:multictr.number, $right#0:multictr.number, ?$$#0:wybe.bool): Alias Pairs: []

    foreign lpvm cast($left#0:multictr.number, ?tmp$0#0:wybe.int)
    foreign llvm and(~tmp$0#0:wybe.int, 7:wybe.int, ?tmp$10#0:wybe.int)
    foreign llvm icmp eq(tmp$10#0:wybe.int, 0:wybe.int, ?tmp$11#0:wybe.bool)
    case ~tmp$11#0:wybe.bool of
    0:
        foreign llvm icmp eq(~tmp$10#0:wybe.int, 1:wybe.int, ?tmp$15#0:wybe.bool)
        case ~tmp$15#0:wybe.bool of
        0:
            foreign llvm move(0:wybe.bool, ?$$#0:wybe.bool)

        1:
            foreign lpvm access(~$left#0:multictr.number, -1:wybe.int, ?$left$float_value#0:wybe.float)
            foreign lpvm cast($right#0:multictr.number, ?tmp$17#0:wybe.int)
            foreign llvm and(~tmp$17#0:wybe.int, 7:wybe.int, ?tmp$18#0:wybe.int)
            foreign llvm icmp eq(~tmp$18#0:wybe.int, 1:wybe.int, ?tmp$19#0:wybe.bool)
            case ~tmp$19#0:wybe.bool of
            0:
                foreign llvm move(0:wybe.bool, ?$$#0:wybe.bool)

            1:
                foreign lpvm access(~$right#0:multictr.number, -1:wybe.int, ?$right$float_value#0:wybe.float)
                foreign llvm fcmp eq(~$left$float_value#0:wybe.float, ~$right$float_value#0:wybe.float, ?$$#0:wybe.bool) @wybe:52:44



    1:
        foreign lpvm access($left#0:multictr.number, 0:wybe.int, ?$left$int_value#0:wybe.int)
        foreign lpvm cast($right#0:multictr.number, ?tmp$13#0:wybe.int)
        foreign llvm and(~tmp$13#0:wybe.int, 7:wybe.int, ?tmp$14#0:wybe.int)
        foreign llvm icmp eq(~tmp$14#0:wybe.int, 0:wybe.int, ?tmp$15#0:wybe.bool)
        case ~tmp$15#0:wybe.bool of
        0:
            foreign llvm move(0:wybe.bool, ?$$#0:wybe.bool)

        1:
            foreign lpvm access(~$right#0:multictr.number, 0:wybe.int, ?$right$int_value#0:wybe.int)
            foreign llvm icmp eq(~$left$int_value#0:wybe.int, ~$right$int_value#0:wybe.int, ?$$#0:wybe.bool) @wybe:28:40




float > public inline (0 calls)
0: float(float_value#0:wybe.float, ?$#0:multictr.number): Alias Pairs: []

    foreign lpvm alloc(8:wybe.int, ?$rec#0:multictr.number)
    foreign lpvm mutate(~%$rec#0:multictr.number, ?%$rec#1:multictr.number, 8:wybe.int, 0:wybe.int, 1:wybe.int, ~float_value#0:wybe.float)
    foreign lpvm cast(~$rec#1:multictr.number, ?$recint#0:wybe.int)
    foreign llvm or(~$recint#0, 1:wybe.int, ?$recinttagged#0:wybe.int)
    foreign lpvm cast(~$recinttagged#0, ?$#0:multictr.number)
float > public inline test (5 calls)
1: float(?float_value#0:wybe.float, $#0:multictr.number, ?$$#0:wybe.bool): Alias Pairs: []

    foreign lpvm cast($#0:multictr.number, ?tmp$1#0:wybe.int)
    foreign llvm and(~tmp$1#0:wybe.int, 7:wybe.int, ?tmp$0#0:wybe.int)
    foreign llvm icmp eq(~tmp$0#0:wybe.int, 1:wybe.int, ?tmp$2#0:wybe.bool)
    case ~tmp$2#0:wybe.bool of
    0:
        foreign llvm move(0:wybe.bool, ?$$#0:wybe.bool)

    1:
        foreign lpvm access(~$#0:multictr.number, -1:wybe.int, ?float_value#0:wybe.float)
        foreign llvm move(1:wybe.bool, ?$$#0:wybe.bool)



float_value > public inline test (0 calls)
0: float_value($rec#0:multictr.number, ?$#0:wybe.float, ?$$#0:wybe.bool): Alias Pairs: []

    foreign lpvm cast($rec#0:multictr.number, ?tmp$1#0:wybe.int)
    foreign llvm and(~tmp$1#0:wybe.int, 7:wybe.int, ?tmp$0#0:wybe.int)
    foreign llvm icmp eq(~tmp$0#0:wybe.int, 1:wybe.int, ?tmp$2#0:wybe.bool)
    case ~tmp$2#0:wybe.bool of
    0:
        foreign llvm move(0:wybe.bool, ?$$#0:wybe.bool)

    1:
        foreign lpvm access(~$rec#0:multictr.number, -1:wybe.int, ?$#0:wybe.float)
        foreign llvm move(1:wybe.bool, ?$$#0:wybe.bool)

float_value > public inline test (0 calls)
1: float_value($rec#0:multictr.number, ?$rec#1:multictr.number, $field#0:wybe.float, ?$$#0:wybe.bool): Alias Pairs: []

    foreign lpvm cast($rec#0:multictr.number, ?tmp$1#0:wybe.int)
    foreign llvm and(~tmp$1#0:wybe.int, 7:wybe.int, ?tmp$0#0:wybe.int)
    foreign llvm icmp eq(~tmp$0#0:wybe.int, 1:wybe.int, ?tmp$2#0:wybe.bool)
    case ~tmp$2#0:wybe.bool of
    0:
        foreign llvm move(0:wybe.bool, ?$$#0:wybe.bool)
        foreign llvm move(~$rec#0:multictr.number, ?$rec#1:multictr.number)

    1:
        foreign lpvm mutate(~%$rec#0:multictr.number, ?%$rec#1:multictr.number, 8:wybe.int, -1:wybe.int, 0:wybe.int, ~$field#0:wybe.float)
        foreign llvm move(1:wybe.bool, ?$$#0:wybe.bool)



int > public inline (0 calls)
0: int(int_value#0:wybe.int, ?$#0:multictr.number): Alias Pairs: []

    foreign lpvm alloc(8:wybe.int, ?$rec#0:multictr.number)
    foreign lpvm mutate(~%$rec#0:multictr.number, ?%$#0:multictr.number, 8:wybe.int, 0:wybe.int, 1:wybe.int, ~int_value#0:wybe.int)
int > public inline test (7 calls)
1: int(?int_value#0:wybe.int, $#0:multictr.number, ?$$#0:wybe.bool): Alias Pairs: []

    foreign lpvm cast($#0:multictr.number, ?tmp$1#0:wybe.int)
    foreign llvm and(~tmp$1#0:wybe.int, 7:wybe.int, ?tmp$0#0:wybe.int)
    foreign llvm icmp eq(~tmp$0#0:wybe.int, 0:wybe.int, ?tmp$2#0:wybe.bool)
    case ~tmp$2#0:wybe.bool of
    0:
        foreign llvm move(0:wybe.bool, ?$$#0:wybe.bool)

    1:
        foreign lpvm access(~$#0:multictr.number, 0:wybe.int, ?int_value#0:wybe.int)
        foreign llvm move(1:wybe.bool, ?$$#0:wybe.bool)



int_value > public inline test (0 calls)
0: int_value($rec#0:multictr.number, ?$#0:wybe.int, ?$$#0:wybe.bool): Alias Pairs: []

    foreign lpvm cast($rec#0:multictr.number, ?tmp$1#0:wybe.int)
    foreign llvm and(~tmp$1#0:wybe.int, 7:wybe.int, ?tmp$0#0:wybe.int)
    foreign llvm icmp eq(~tmp$0#0:wybe.int, 0:wybe.int, ?tmp$2#0:wybe.bool)
    case ~tmp$2#0:wybe.bool of
    0:
        foreign llvm move(0:wybe.bool, ?$$#0:wybe.bool)

    1:
        foreign lpvm access(~$rec#0:multictr.number, 0:wybe.int, ?$#0:wybe.int)
        foreign llvm move(1:wybe.bool, ?$$#0:wybe.bool)

int_value > public inline test (0 calls)
1: int_value($rec#0:multictr.number, ?$rec#1:multictr.number, $field#0:wybe.int, ?$$#0:wybe.bool): Alias Pairs: []

    foreign lpvm cast($rec#0:multictr.number, ?tmp$1#0:wybe.int)
    foreign llvm and(~tmp$1#0:wybe.int, 7:wybe.int, ?tmp$0#0:wybe.int)
    foreign llvm icmp eq(~tmp$0#0:wybe.int, 0:wybe.int, ?tmp$2#0:wybe.bool)
    case ~tmp$2#0:wybe.bool of
    0:
        foreign llvm move(0:wybe.bool, ?$$#0:wybe.bool)
        foreign llvm move(~$rec#0:multictr.number, ?$rec#1:multictr.number)

    1:
        foreign lpvm mutate(~%$rec#0:multictr.number, ?%$rec#1:multictr.number, 8:wybe.int, 0:wybe.int, 0:wybe.int, ~$field#0:wybe.int)
        foreign llvm move(1:wybe.bool, ?$$#0:wybe.bool)

--------------------------------------------------
 Module multictr.simple([])
  public submods  : 
  public types    : 
  public resources: 
  public procs    : multictr.simple.=<0>
                    multictr.simple.=<1>
                    multictr.simple.=<2>
                    multictr.simple.one<0>
                    multictr.simple.one<1>
                    multictr.simple.one_field<0>
                    multictr.simple.one_field<1>
                    multictr.simple.two<0>
                    multictr.simple.two<1>
                    multictr.simple.two_field<0>
                    multictr.simple.two_field<1>
                    multictr.simple.zero<0>
  imports         : use wybe
  types           : 
  resources       : 
  procs           : 

= > public inline (0 calls)
0: =(?out#0:multictr.simple, in#0:multictr.simple): Alias Pairs: []

    foreign llvm move(~in#0:multictr.simple, ?out#0:multictr.simple)
= > public inline (0 calls)
1: =(in#0:multictr.simple, ?out#0:multictr.simple): Alias Pairs: []

    foreign llvm move(~in#0:multictr.simple, ?out#0:multictr.simple)
= > public test (2 calls)
2: =($left#0:multictr.simple, $right#0:multictr.simple, ?$$#0:wybe.bool): Alias Pairs: []

    foreign lpvm cast($left#0:multictr.simple, ?tmp$0#0:wybe.int)
    foreign llvm icmp eq(tmp$0#0:wybe.int, 0:wybe.int, ?tmp$1#0:wybe.bool)
    case ~tmp$1#0:wybe.bool of
    0:
        foreign llvm icmp ne(tmp$0#0:wybe.int, 0:wybe.int, ?tmp$11#0:wybe.bool)
        case tmp$11#0:wybe.bool of
        0:
            case ~tmp$11#0:wybe.bool of
            0:
                foreign llvm move(0:wybe.bool, ?$$#0:wybe.bool)

            1:
                foreign llvm and(~tmp$0#0:wybe.int, 7:wybe.int, ?tmp$17#0:wybe.int)
                foreign llvm icmp eq(~tmp$17#0:wybe.int, 1:wybe.int, ?tmp$18#0:wybe.bool)
                case ~tmp$18#0:wybe.bool of
                0:
                    foreign llvm move(0:wybe.bool, ?$$#0:wybe.bool)

                1:
                    foreign lpvm access(~$left#0:multictr.simple, -1:wybe.int, ?$left$two_field#0:wybe.int)
                    foreign lpvm cast($right#0:multictr.simple, ?tmp$20#0:wybe.int)
                    foreign llvm icmp ne(tmp$20#0:wybe.int, 0:wybe.int, ?tmp$21#0:wybe.bool)
                    case ~tmp$21#0:wybe.bool of
                    0:
                        foreign llvm move(0:wybe.bool, ?$$#0:wybe.bool)

                    1:
                        foreign llvm and(~tmp$20#0:wybe.int, 7:wybe.int, ?tmp$22#0:wybe.int)
                        foreign llvm icmp eq(~tmp$22#0:wybe.int, 1:wybe.int, ?tmp$23#0:wybe.bool)
                        case ~tmp$23#0:wybe.bool of
                        0:
                            foreign llvm move(0:wybe.bool, ?$$#0:wybe.bool)

                        1:
                            foreign lpvm access(~$right#0:multictr.simple, -1:wybe.int, ?$right$two_field#0:wybe.int)
                            foreign llvm icmp eq(~$left$two_field#0:wybe.int, ~$right$two_field#0:wybe.int, ?$$#0:wybe.bool) @wybe:28:40





        1:
            foreign llvm and(tmp$0#0:wybe.int, 7:wybe.int, ?tmp$12#0:wybe.int)
            foreign llvm icmp eq(~tmp$12#0:wybe.int, 0:wybe.int, ?tmp$13#0:wybe.bool)
            case ~tmp$13#0:wybe.bool of
            0:
                case ~tmp$11#0:wybe.bool of
                0:
                    foreign llvm move(0:wybe.bool, ?$$#0:wybe.bool)

                1:
                    foreign llvm and(~tmp$0#0:wybe.int, 7:wybe.int, ?tmp$17#0:wybe.int)
                    foreign llvm icmp eq(~tmp$17#0:wybe.int, 1:wybe.int, ?tmp$18#0:wybe.bool)
                    case ~tmp$18#0:wybe.bool of
                    0:
                        foreign llvm move(0:wybe.bool, ?$$#0:wybe.bool)

                    1:
                        foreign lpvm access(~$left#0:multictr.simple, -1:wybe.int, ?$left$two_field#0:wybe.int)
                        foreign lpvm cast($right#0:multictr.simple, ?tmp$20#0:wybe.int)
                        foreign llvm icmp ne(tmp$20#0:wybe.int, 0:wybe.int, ?tmp$21#0:wybe.bool)
                        case ~tmp$21#0:wybe.bool of
                        0:
                            foreign llvm move(0:wybe.bool, ?$$#0:wybe.bool)

                        1:
                            foreign llvm and(~tmp$20#0:wybe.int, 7:wybe.int, ?tmp$22#0:wybe.int)
                            foreign llvm icmp eq(~tmp$22#0:wybe.int, 1:wybe.int, ?tmp$23#0:wybe.bool)
                            case ~tmp$23#0:wybe.bool of
                            0:
                                foreign llvm move(0:wybe.bool, ?$$#0:wybe.bool)

                            1:
                                foreign lpvm access(~$right#0:multictr.simple, -1:wybe.int, ?$right$two_field#0:wybe.int)
                                foreign llvm icmp eq(~$left$two_field#0:wybe.int, ~$right$two_field#0:wybe.int, ?$$#0:wybe.bool) @wybe:28:40





            1:
                foreign lpvm access($left#0:multictr.simple, 0:wybe.int, ?$left$one_field#0:wybe.int)
                foreign lpvm cast($right#0:multictr.simple, ?tmp$15#0:wybe.int)
                foreign llvm icmp ne(tmp$15#0:wybe.int, 0:wybe.int, ?tmp$16#0:wybe.bool)
                case ~tmp$16#0:wybe.bool of
                0:
                    foreign llvm move(0:wybe.bool, ?$$#0:wybe.bool)

                1:
                    foreign llvm and(~tmp$15#0:wybe.int, 7:wybe.int, ?tmp$17#0:wybe.int)
                    foreign llvm icmp eq(~tmp$17#0:wybe.int, 0:wybe.int, ?tmp$18#0:wybe.bool)
                    case ~tmp$18#0:wybe.bool of
                    0:
                        foreign llvm move(0:wybe.bool, ?$$#0:wybe.bool)

                    1:
                        foreign lpvm access(~$right#0:multictr.simple, 0:wybe.int, ?$right$one_field#0:wybe.int)
                        foreign llvm icmp eq(~$left$one_field#0:wybe.int, ~$right$one_field#0:wybe.int, ?$$#0:wybe.bool) @wybe:28:40





    1:
        foreign llvm icmp eq(~$left#0:wybe.int, ~$right#0:wybe.int, ?$$#0:wybe.bool)



one > public inline (0 calls)
0: one(one_field#0:wybe.int, ?$#0:multictr.simple): Alias Pairs: []

    foreign lpvm alloc(8:wybe.int, ?$rec#0:multictr.simple)
    foreign lpvm mutate(~%$rec#0:multictr.simple, ?%$#0:multictr.simple, 8:wybe.int, 0:wybe.int, 1:wybe.int, ~one_field#0:wybe.int)
one > public inline test (7 calls)
1: one(?one_field#0:wybe.int, $#0:multictr.simple, ?$$#0:wybe.bool): Alias Pairs: []

    foreign lpvm cast($#0:multictr.simple, ?tmp$0#0:wybe.int)
    foreign llvm icmp ne(tmp$0#0:wybe.int, 0:wybe.int, ?tmp$1#0:wybe.bool)
    case ~tmp$1#0:wybe.bool of
    0:
        foreign llvm move(0:wybe.bool, ?$$#0:wybe.bool)

    1:
        foreign llvm and(~tmp$0#0:wybe.int, 7:wybe.int, ?tmp$2#0:wybe.int)
        foreign llvm icmp eq(~tmp$2#0:wybe.int, 0:wybe.int, ?tmp$4#0:wybe.bool)
        case ~tmp$4#0:wybe.bool of
        0:
            foreign llvm move(0:wybe.bool, ?$$#0:wybe.bool)

        1:
            foreign lpvm access(~$#0:multictr.simple, 0:wybe.int, ?one_field#0:wybe.int)
            foreign llvm move(1:wybe.bool, ?$$#0:wybe.bool)




one_field > public inline test (0 calls)
0: one_field($rec#0:multictr.simple, ?$#0:wybe.int, ?$$#0:wybe.bool): Alias Pairs: []

    foreign lpvm cast($rec#0:multictr.simple, ?tmp$0#0:wybe.int)
    foreign llvm icmp ne(tmp$0#0:wybe.int, 0:wybe.int, ?tmp$1#0:wybe.bool)
    case ~tmp$1#0:wybe.bool of
    0:
        foreign llvm move(0:wybe.bool, ?$$#0:wybe.bool)

    1:
        foreign llvm and(~tmp$0#0:wybe.int, 7:wybe.int, ?tmp$2#0:wybe.int)
        foreign llvm icmp eq(~tmp$2#0:wybe.int, 0:wybe.int, ?tmp$4#0:wybe.bool)
        case ~tmp$4#0:wybe.bool of
        0:
            foreign llvm move(0:wybe.bool, ?$$#0:wybe.bool)

        1:
            foreign lpvm access(~$rec#0:multictr.simple, 0:wybe.int, ?$#0:wybe.int)
            foreign llvm move(1:wybe.bool, ?$$#0:wybe.bool)


one_field > public inline test (0 calls)
1: one_field($rec#0:multictr.simple, ?$rec#1:multictr.simple, $field#0:wybe.int, ?$$#0:wybe.bool): Alias Pairs: []

    foreign lpvm cast($rec#0:multictr.simple, ?tmp$0#0:wybe.int)
    foreign llvm icmp ne(tmp$0#0:wybe.int, 0:wybe.int, ?tmp$1#0:wybe.bool)
    case ~tmp$1#0:wybe.bool of
    0:
        foreign llvm move(0:wybe.bool, ?$$#0:wybe.bool)
        foreign llvm move(~$rec#0:multictr.simple, ?$rec#1:multictr.simple)

    1:
        foreign llvm and(~tmp$0#0:wybe.int, 7:wybe.int, ?tmp$2#0:wybe.int)
        foreign llvm icmp eq(~tmp$2#0:wybe.int, 0:wybe.int, ?tmp$4#0:wybe.bool)
        case ~tmp$4#0:wybe.bool of
        0:
            foreign llvm move(0:wybe.bool, ?$$#0:wybe.bool)
            foreign llvm move(~$rec#0:multictr.simple, ?$rec#1:multictr.simple)

        1:
            foreign lpvm mutate(~%$rec#0:multictr.simple, ?%$rec#1:multictr.simple, 8:wybe.int, 0:wybe.int, 0:wybe.int, ~$field#0:wybe.int)
            foreign llvm move(1:wybe.bool, ?$$#0:wybe.bool)




two > public inline (0 calls)
0: two(two_field#0:wybe.int, ?$#0:multictr.simple): Alias Pairs: []

    foreign lpvm alloc(8:wybe.int, ?$rec#0:multictr.simple)
    foreign lpvm mutate(~%$rec#0:multictr.simple, ?%$rec#1:multictr.simple, 8:wybe.int, 0:wybe.int, 1:wybe.int, ~two_field#0:wybe.int)
    foreign lpvm cast(~$rec#1:multictr.simple, ?$recint#0:wybe.int)
    foreign llvm or(~$recint#0, 1:wybe.int, ?$recinttagged#0:wybe.int)
    foreign lpvm cast(~$recinttagged#0, ?$#0:multictr.simple)
two > public inline test (5 calls)
1: two(?two_field#0:wybe.int, $#0:multictr.simple, ?$$#0:wybe.bool): Alias Pairs: []

    foreign lpvm cast($#0:multictr.simple, ?tmp$0#0:wybe.int)
    foreign llvm icmp ne(tmp$0#0:wybe.int, 0:wybe.int, ?tmp$1#0:wybe.bool)
    case ~tmp$1#0:wybe.bool of
    0:
        foreign llvm move(0:wybe.bool, ?$$#0:wybe.bool)

    1:
        foreign llvm and(~tmp$0#0:wybe.int, 7:wybe.int, ?tmp$2#0:wybe.int)
        foreign llvm icmp eq(~tmp$2#0:wybe.int, 1:wybe.int, ?tmp$4#0:wybe.bool)
        case ~tmp$4#0:wybe.bool of
        0:
            foreign llvm move(0:wybe.bool, ?$$#0:wybe.bool)

        1:
            foreign lpvm access(~$#0:multictr.simple, -1:wybe.int, ?two_field#0:wybe.int)
            foreign llvm move(1:wybe.bool, ?$$#0:wybe.bool)




two_field > public inline test (0 calls)
0: two_field($rec#0:multictr.simple, ?$#0:wybe.int, ?$$#0:wybe.bool): Alias Pairs: []

    foreign lpvm cast($rec#0:multictr.simple, ?tmp$0#0:wybe.int)
    foreign llvm icmp ne(tmp$0#0:wybe.int, 0:wybe.int, ?tmp$1#0:wybe.bool)
    case ~tmp$1#0:wybe.bool of
    0:
        foreign llvm move(0:wybe.bool, ?$$#0:wybe.bool)

    1:
        foreign llvm and(~tmp$0#0:wybe.int, 7:wybe.int, ?tmp$2#0:wybe.int)
        foreign llvm icmp eq(~tmp$2#0:wybe.int, 1:wybe.int, ?tmp$4#0:wybe.bool)
        case ~tmp$4#0:wybe.bool of
        0:
            foreign llvm move(0:wybe.bool, ?$$#0:wybe.bool)

        1:
            foreign lpvm access(~$rec#0:multictr.simple, -1:wybe.int, ?$#0:wybe.int)
            foreign llvm move(1:wybe.bool, ?$$#0:wybe.bool)


two_field > public inline test (0 calls)
1: two_field($rec#0:multictr.simple, ?$rec#1:multictr.simple, $field#0:wybe.int, ?$$#0:wybe.bool): Alias Pairs: []

    foreign lpvm cast($rec#0:multictr.simple, ?tmp$0#0:wybe.int)
    foreign llvm icmp ne(tmp$0#0:wybe.int, 0:wybe.int, ?tmp$1#0:wybe.bool)
    case ~tmp$1#0:wybe.bool of
    0:
        foreign llvm move(0:wybe.bool, ?$$#0:wybe.bool)
        foreign llvm move(~$rec#0:multictr.simple, ?$rec#1:multictr.simple)

    1:
        foreign llvm and(~tmp$0#0:wybe.int, 7:wybe.int, ?tmp$2#0:wybe.int)
        foreign llvm icmp eq(~tmp$2#0:wybe.int, 1:wybe.int, ?tmp$4#0:wybe.bool)
        case ~tmp$4#0:wybe.bool of
        0:
            foreign llvm move(0:wybe.bool, ?$$#0:wybe.bool)
            foreign llvm move(~$rec#0:multictr.simple, ?$rec#1:multictr.simple)

        1:
            foreign lpvm mutate(~%$rec#0:multictr.simple, ?%$rec#1:multictr.simple, 8:wybe.int, -1:wybe.int, 0:wybe.int, ~$field#0:wybe.int)
            foreign llvm move(1:wybe.bool, ?$$#0:wybe.bool)




zero > public inline (0 calls)
0: zero(?$#0:multictr.simple): Alias Pairs: []

    foreign lpvm cast(0:multictr.simple, ?$#0:multictr.simple)
multictr, multictr.number, multictr.simple
======================================================================
AFTER LLVM IR:

; ModuleID = 'multictr'
source_filename = "test-cases/multictr.wybe"

declare i8* @wybe_malloc(i32) local_unnamed_addr

; Function Attrs: norecurse nounwind readnone
define i64* @"multictr.number.=<0>"(i64* readnone returned %"in#0") local_unnamed_addr #0 {
entry:
  ret i64* %"in#0"
}

; Function Attrs: norecurse nounwind readnone
define i64* @"multictr.number.=<1>"(i64* readnone returned %"in#0") local_unnamed_addr #0 {
entry:
  ret i64* %"in#0"
}

; Function Attrs: norecurse nounwind readonly
define i1 @"multictr.number.=<2>"(i64* %"$left#0", i64* %"$right#0") local_unnamed_addr #1 {
entry:
  %0 = ptrtoint i64* %"$left#0" to i64
  %"tmp$10#0" = and i64 %0, 7
  %"tmp$11#0" = icmp eq i64 %"tmp$10#0", 0
  br i1 %"tmp$11#0", label %if.then, label %if.else

if.then:                                          ; preds = %entry
  %1 = ptrtoint i64* %"$right#0" to i64
  %"tmp$14#0" = and i64 %1, 7
  %"tmp$15#0" = icmp eq i64 %"tmp$14#0", 0
  br i1 %"tmp$15#0", label %if.then1, label %if.else1

if.else:                                          ; preds = %entry
  %"tmp$15#01" = icmp eq i64 %"tmp$10#0", 1
  br i1 %"tmp$15#01", label %if.then2, label %if.else1

if.then1:                                         ; preds = %if.then
  %2 = load i64, i64* %"$left#0", align 4
  %3 = load i64, i64* %"$right#0", align 4
  %"$$#0" = icmp eq i64 %2, %3
  ret i1 %"$$#0"

if.else1:                                         ; preds = %if.then2, %if.else, %if.then
  %merge = phi i1 [ false, %if.else ], [ %"tmp$15#01", %if.then ], [ false, %if.then2 ]
  ret i1 %merge

if.then2:                                         ; preds = %if.else
  %4 = ptrtoint i64* %"$right#0" to i64
  %"tmp$18#0" = and i64 %4, 7
  %"tmp$19#0" = icmp eq i64 %"tmp$18#0", 1
  br i1 %"tmp$19#0", label %if.then3, label %if.else1

if.then3:                                         ; preds = %if.then2
  %5 = load i64, i64* %"$left#0", align 4
  %6 = load i64, i64* %"$right#0", align 4
  %"$$#02" = fcmp oeq i64 %5, %6
  ret i1 %"$$#02"
}

define nonnull i64* @"multictr.number.float<0>"(double %"float_value#0") local_unnamed_addr {
entry:
  %0 = tail call i8* @wybe_malloc(i32 8)
  %1 = bitcast i8* %0 to i64*
  store double %"float_value#0", i64* %1, align 8
  %2 = ptrtoint i8* %0 to i64
  %"$recinttagged#0" = or i64 %2, 1
  %3 = inttoptr i64 %"$recinttagged#0" to i64*
  ret i64* %3
}

; Function Attrs: norecurse nounwind readnone
define { double, i1 } @"multictr.number.float<1>"(i64* %"$#0") local_unnamed_addr #0 {
entry:
  %0 = ptrtoint i64* %"$#0" to i64
  %"tmp$0#0" = and i64 %0, 7
  %"tmp$2#0" = icmp eq i64 %"tmp$0#0", 1
  ret i1 %"tmp$2#0"
}

; Function Attrs: norecurse nounwind readnone
define { double, i1 } @"multictr.number.float_value<0>"(i64* %"$rec#0") local_unnamed_addr #0 {
entry:
  %0 = ptrtoint i64* %"$rec#0" to i64
  %"tmp$0#0" = and i64 %0, 7
  %"tmp$2#0" = icmp eq i64 %"tmp$0#0", 1
  ret i1 %"tmp$2#0"
}

define { i64*, i1 } @"multictr.number.float_value<1>"(i64* %"$rec#0", double %"$field#0") local_unnamed_addr {
entry:
  %0 = ptrtoint i64* %"$rec#0" to i64
  %"tmp$0#0" = and i64 %0, 7
  %"tmp$2#0" = icmp eq i64 %"tmp$0#0", 1
  br i1 %"tmp$2#0", label %if.then, label %if.else

if.then:                                          ; preds = %entry
  %1 = tail call i8* @wybe_malloc(i32 8)
  store double %"$field#0", i64* %"$rec#0", align 8
  ret i1 true

if.else:                                          ; preds = %entry
  ret i64* %"$rec#0"
}

define i64* @"multictr.number.int<0>"(i64 %"int_value#0") local_unnamed_addr {
entry:
  %0 = tail call i8* @wybe_malloc(i32 8)
  %1 = bitcast i8* %0 to i64*
  store i64 %"int_value#0", i64* %1, align 4
  ret i64* %1
}

; Function Attrs: norecurse nounwind readnone
define { i64, i1 } @"multictr.number.int<1>"(i64* %"$#0") local_unnamed_addr #0 {
entry:
  %0 = ptrtoint i64* %"$#0" to i64
  %"tmp$0#0" = and i64 %0, 7
  %"tmp$2#0" = icmp eq i64 %"tmp$0#0", 0
  ret i1 %"tmp$2#0"
}

; Function Attrs: norecurse nounwind readnone
define { i64, i1 } @"multictr.number.int_value<0>"(i64* %"$rec#0") local_unnamed_addr #0 {
entry:
  %0 = ptrtoint i64* %"$rec#0" to i64
  %"tmp$0#0" = and i64 %0, 7
  %"tmp$2#0" = icmp eq i64 %"tmp$0#0", 0
  ret i1 %"tmp$2#0"
}

define { i64*, i1 } @"multictr.number.int_value<1>"(i64* %"$rec#0", i64 %"$field#0") local_unnamed_addr {
entry:
  %0 = ptrtoint i64* %"$rec#0" to i64
  %"tmp$0#0" = and i64 %0, 7
  %"tmp$2#0" = icmp eq i64 %"tmp$0#0", 0
  br i1 %"tmp$2#0", label %if.then, label %if.else

if.then:                                          ; preds = %entry
  %1 = tail call i8* @wybe_malloc(i32 8)
  store i64 %"$field#0", i64* %"$rec#0", align 4
  ret i1 true

if.else:                                          ; preds = %entry
  ret i64* %"$rec#0"
}

; Function Attrs: norecurse nounwind readnone
define i64* @"multictr.simple.=<0>"(i64* readnone returned %"in#0") local_unnamed_addr #0 {
entry:
  ret i64* %"in#0"
}

; Function Attrs: norecurse nounwind readnone
define i64* @"multictr.simple.=<1>"(i64* readnone returned %"in#0") local_unnamed_addr #0 {
entry:
  ret i64* %"in#0"
}

; Function Attrs: norecurse nounwind readonly
define i1 @"multictr.simple.=<2>"(i64* %"$left#0", i64* %"$right#0") local_unnamed_addr #1 {
entry:
  %"tmp$1#0" = icmp eq i64* %"$left#0", null
  br i1 %"tmp$1#0", label %if.then, label %if.then1

if.then:                                          ; preds = %entry
  %"$$#0" = icmp eq i64* %"$right#0", null
  ret i1 %"$$#0"

if.then1:                                         ; preds = %entry
  %0 = ptrtoint i64* %"$left#0" to i64
  %trunc = trunc i64 %0 to i3
  switch i3 %trunc, label %if.else3 [
    i3 0, label %if.then2
    i3 1, label %if.then6
  ]

if.then2:                                         ; preds = %if.then1
  %1 = load i64, i64* %"$left#0", align 4
  %"tmp$16#0" = icmp eq i64* %"$right#0", null
  br i1 %"tmp$16#0", label %if.else3, label %if.then3

if.then3:                                         ; preds = %if.then2
  %2 = ptrtoint i64* %"$right#0" to i64
  %"tmp$17#0" = and i64 %2, 7
  %"tmp$18#0" = icmp eq i64 %"tmp$17#0", 0
  br i1 %"tmp$18#0", label %if.then4, label %if.else3

if.else3:                                         ; preds = %if.then2, %if.then6, %if.then1, %if.then7, %if.then3
  ret i1 false

if.then4:                                         ; preds = %if.then3
  %3 = load i64, i64* %"$right#0", align 4
  %"$$#01" = icmp eq i64 %1, %3
  ret i1 %"$$#01"

if.then6:                                         ; preds = %if.then1
  %4 = load i64, i64* %"$left#0", align 4
  %"tmp$21#0" = icmp eq i64* %"$right#0", null
  br i1 %"tmp$21#0", label %if.else3, label %if.then7

if.then7:                                         ; preds = %if.then6
  %5 = ptrtoint i64* %"$right#0" to i64
  %"tmp$22#0" = and i64 %5, 7
  %"tmp$23#0" = icmp eq i64 %"tmp$22#0", 1
  br i1 %"tmp$23#0", label %if.then8, label %if.else3

if.then8:                                         ; preds = %if.then7
  %6 = load i64, i64* %"$right#0", align 4
  %"$$#04" = icmp eq i64 %4, %6
  ret i1 %"$$#04"
}

define i64* @"multictr.simple.one<0>"(i64 %"one_field#0") local_unnamed_addr {
entry:
  %0 = tail call i8* @wybe_malloc(i32 8)
  %1 = bitcast i8* %0 to i64*
  store i64 %"one_field#0", i64* %1, align 4
  ret i64* %1
}

; Function Attrs: norecurse nounwind readnone
define { i64, i1 } @"multictr.simple.one<1>"(i64* %"$#0") local_unnamed_addr #0 {
entry:
  %"tmp$1#0" = icmp eq i64* %"$#0", null
  br i1 %"tmp$1#0", label %if.else, label %if.then

if.then:                                          ; preds = %entry
  %0 = ptrtoint i64* %"$#0" to i64
  %"tmp$2#0" = and i64 %0, 7
  %"tmp$4#0" = icmp eq i64 %"tmp$2#0", 0
  br label %if.else

if.else:                                          ; preds = %if.then, %entry
  %merge = phi i1 [ false, %entry ], [ %"tmp$4#0", %if.then ]
  ret i1 %merge
}

; Function Attrs: norecurse nounwind readnone
define { i64, i1 } @"multictr.simple.one_field<0>"(i64* %"$rec#0") local_unnamed_addr #0 {
entry:
  %"tmp$1#0" = icmp eq i64* %"$rec#0", null
  br i1 %"tmp$1#0", label %if.else, label %if.then

if.then:                                          ; preds = %entry
  %0 = ptrtoint i64* %"$rec#0" to i64
  %"tmp$2#0" = and i64 %0, 7
  %"tmp$4#0" = icmp eq i64 %"tmp$2#0", 0
  br label %if.else

if.else:                                          ; preds = %if.then, %entry
  %merge = phi i1 [ false, %entry ], [ %"tmp$4#0", %if.then ]
  ret i1 %merge
}

define { i64*, i1 } @"multictr.simple.one_field<1>"(i64* %"$rec#0", i64 %"$field#0") local_unnamed_addr {
entry:
  %"tmp$1#0" = icmp eq i64* %"$rec#0", null
  br i1 %"tmp$1#0", label %if.else, label %if.then

if.then:                                          ; preds = %entry
  %0 = ptrtoint i64* %"$rec#0" to i64
  %"tmp$2#0" = and i64 %0, 7
  %"tmp$4#0" = icmp eq i64 %"tmp$2#0", 0
  br i1 %"tmp$4#0", label %if.then1, label %if.else

if.else:                                          ; preds = %if.then, %entry
  ret i1 false

if.then1:                                         ; preds = %if.then
  %1 = tail call i8* @wybe_malloc(i32 8)
  store i64 %"$field#0", i64* %"$rec#0", align 4
  ret i1 true
}

define nonnull i64* @"multictr.simple.two<0>"(i64 %"two_field#0") local_unnamed_addr {
entry:
  %0 = tail call i8* @wybe_malloc(i32 8)
  %1 = bitcast i8* %0 to i64*
  store i64 %"two_field#0", i64* %1, align 4
  %2 = ptrtoint i8* %0 to i64
  %"$recinttagged#0" = or i64 %2, 1
  %3 = inttoptr i64 %"$recinttagged#0" to i64*
  ret i64* %3
}

; Function Attrs: norecurse nounwind readnone
define { i64, i1 } @"multictr.simple.two<1>"(i64* %"$#0") local_unnamed_addr #0 {
entry:
  %"tmp$1#0" = icmp eq i64* %"$#0", null
  br i1 %"tmp$1#0", label %if.else, label %if.then

if.then:                                          ; preds = %entry
  %0 = ptrtoint i64* %"$#0" to i64
  %"tmp$2#0" = and i64 %0, 7
  %"tmp$4#0" = icmp eq i64 %"tmp$2#0", 1
  br label %if.else

if.else:                                          ; preds = %if.then, %entry
  %merge = phi i1 [ false, %entry ], [ %"tmp$4#0", %if.then ]
  ret i1 %merge
}

; Function Attrs: norecurse nounwind readnone
define { i64, i1 } @"multictr.simple.two_field<0>"(i64* %"$rec#0") local_unnamed_addr #0 {
entry:
  %"tmp$1#0" = icmp eq i64* %"$rec#0", null
  br i1 %"tmp$1#0", label %if.else, label %if.then

if.then:                                          ; preds = %entry
  %0 = ptrtoint i64* %"$rec#0" to i64
  %"tmp$2#0" = and i64 %0, 7
  %"tmp$4#0" = icmp eq i64 %"tmp$2#0", 1
  br label %if.else

if.else:                                          ; preds = %if.then, %entry
  %merge = phi i1 [ false, %entry ], [ %"tmp$4#0", %if.then ]
  ret i1 %merge
}

define { i64*, i1 } @"multictr.simple.two_field<1>"(i64* %"$rec#0", i64 %"$field#0") local_unnamed_addr {
entry:
  %"tmp$1#0" = icmp eq i64* %"$rec#0", null
  br i1 %"tmp$1#0", label %if.else, label %if.then

if.then:                                          ; preds = %entry
  %0 = ptrtoint i64* %"$rec#0" to i64
  %"tmp$2#0" = and i64 %0, 7
  %"tmp$4#0" = icmp eq i64 %"tmp$2#0", 1
  br i1 %"tmp$4#0", label %if.then1, label %if.else

if.else:                                          ; preds = %if.then, %entry
  ret i1 false

if.then1:                                         ; preds = %if.then
  %1 = tail call i8* @wybe_malloc(i32 8)
  store i64 %"$field#0", i64* %"$rec#0", align 4
  ret i1 true
}

; Function Attrs: norecurse nounwind readnone
define noalias i64* @"multictr.simple.zero<0>"() local_unnamed_addr #0 {
entry:
  ret i64* null
}

attributes #0 = { norecurse nounwind readnone }
attributes #1 = { norecurse nounwind readonly }

--------------------------------------------------
; ModuleID = 'multictr.number'
source_filename = "test-cases"

declare i8* @wybe_malloc(i32) local_unnamed_addr

; Function Attrs: norecurse nounwind readnone
define i64* @"multictr.number.=<0>"(i64* readnone returned %"in#0") local_unnamed_addr #0 {
entry:
  ret i64* %"in#0"
}

; Function Attrs: norecurse nounwind readnone
define i64* @"multictr.number.=<1>"(i64* readnone returned %"in#0") local_unnamed_addr #0 {
entry:
  ret i64* %"in#0"
}

; Function Attrs: norecurse nounwind readonly
define i1 @"multictr.number.=<2>"(i64* %"$left#0", i64* %"$right#0") local_unnamed_addr #1 {
entry:
  %0 = ptrtoint i64* %"$left#0" to i64
  %"tmp$10#0" = and i64 %0, 7
  %"tmp$11#0" = icmp eq i64 %"tmp$10#0", 0
  br i1 %"tmp$11#0", label %if.then, label %if.else

if.then:                                          ; preds = %entry
  %1 = ptrtoint i64* %"$right#0" to i64
  %"tmp$14#0" = and i64 %1, 7
  %"tmp$15#0" = icmp eq i64 %"tmp$14#0", 0
  br i1 %"tmp$15#0", label %if.then1, label %if.else1

if.else:                                          ; preds = %entry
  %"tmp$15#01" = icmp eq i64 %"tmp$10#0", 1
  br i1 %"tmp$15#01", label %if.then2, label %if.else1

if.then1:                                         ; preds = %if.then
  %2 = load i64, i64* %"$left#0", align 4
  %3 = load i64, i64* %"$right#0", align 4
  %"$$#0" = icmp eq i64 %2, %3
  ret i1 %"$$#0"

if.else1:                                         ; preds = %if.then2, %if.else, %if.then
  %merge = phi i1 [ false, %if.else ], [ %"tmp$15#01", %if.then ], [ false, %if.then2 ]
  ret i1 %merge

if.then2:                                         ; preds = %if.else
  %4 = ptrtoint i64* %"$right#0" to i64
  %"tmp$18#0" = and i64 %4, 7
  %"tmp$19#0" = icmp eq i64 %"tmp$18#0", 1
  br i1 %"tmp$19#0", label %if.then3, label %if.else1

if.then3:                                         ; preds = %if.then2
  %5 = load i64, i64* %"$left#0", align 4
  %6 = load i64, i64* %"$right#0", align 4
  %"$$#02" = fcmp oeq i64 %5, %6
  ret i1 %"$$#02"
}

define nonnull i64* @"multictr.number.float<0>"(double %"float_value#0") local_unnamed_addr {
entry:
  %0 = tail call i8* @wybe_malloc(i32 8)
  %1 = bitcast i8* %0 to i64*
  store double %"float_value#0", i64* %1, align 8
  %2 = ptrtoint i8* %0 to i64
  %"$recinttagged#0" = or i64 %2, 1
  %3 = inttoptr i64 %"$recinttagged#0" to i64*
  ret i64* %3
}

; Function Attrs: norecurse nounwind readnone
define { double, i1 } @"multictr.number.float<1>"(i64* %"$#0") local_unnamed_addr #0 {
entry:
  %0 = ptrtoint i64* %"$#0" to i64
  %"tmp$0#0" = and i64 %0, 7
  %"tmp$2#0" = icmp eq i64 %"tmp$0#0", 1
  ret i1 %"tmp$2#0"
}

; Function Attrs: norecurse nounwind readnone
define { double, i1 } @"multictr.number.float_value<0>"(i64* %"$rec#0") local_unnamed_addr #0 {
entry:
  %0 = ptrtoint i64* %"$rec#0" to i64
  %"tmp$0#0" = and i64 %0, 7
  %"tmp$2#0" = icmp eq i64 %"tmp$0#0", 1
  ret i1 %"tmp$2#0"
}

define { i64*, i1 } @"multictr.number.float_value<1>"(i64* %"$rec#0", double %"$field#0") local_unnamed_addr {
entry:
  %0 = ptrtoint i64* %"$rec#0" to i64
  %"tmp$0#0" = and i64 %0, 7
  %"tmp$2#0" = icmp eq i64 %"tmp$0#0", 1
  br i1 %"tmp$2#0", label %if.then, label %if.else

if.then:                                          ; preds = %entry
  %1 = tail call i8* @wybe_malloc(i32 8)
  store double %"$field#0", i64* %"$rec#0", align 8
  ret i1 true

if.else:                                          ; preds = %entry
  ret i64* %"$rec#0"
}

define i64* @"multictr.number.int<0>"(i64 %"int_value#0") local_unnamed_addr {
entry:
  %0 = tail call i8* @wybe_malloc(i32 8)
  %1 = bitcast i8* %0 to i64*
  store i64 %"int_value#0", i64* %1, align 4
  ret i64* %1
}

; Function Attrs: norecurse nounwind readnone
define { i64, i1 } @"multictr.number.int<1>"(i64* %"$#0") local_unnamed_addr #0 {
entry:
  %0 = ptrtoint i64* %"$#0" to i64
  %"tmp$0#0" = and i64 %0, 7
  %"tmp$2#0" = icmp eq i64 %"tmp$0#0", 0
  ret i1 %"tmp$2#0"
}

; Function Attrs: norecurse nounwind readnone
define { i64, i1 } @"multictr.number.int_value<0>"(i64* %"$rec#0") local_unnamed_addr #0 {
entry:
  %0 = ptrtoint i64* %"$rec#0" to i64
  %"tmp$0#0" = and i64 %0, 7
  %"tmp$2#0" = icmp eq i64 %"tmp$0#0", 0
  ret i1 %"tmp$2#0"
}

define { i64*, i1 } @"multictr.number.int_value<1>"(i64* %"$rec#0", i64 %"$field#0") local_unnamed_addr {
entry:
  %0 = ptrtoint i64* %"$rec#0" to i64
  %"tmp$0#0" = and i64 %0, 7
  %"tmp$2#0" = icmp eq i64 %"tmp$0#0", 0
  br i1 %"tmp$2#0", label %if.then, label %if.else

if.then:                                          ; preds = %entry
  %1 = tail call i8* @wybe_malloc(i32 8)
  store i64 %"$field#0", i64* %"$rec#0", align 4
  ret i1 true

if.else:                                          ; preds = %entry
  ret i64* %"$rec#0"
}

attributes #0 = { norecurse nounwind readnone }
attributes #1 = { norecurse nounwind readonly }

--------------------------------------------------
; ModuleID = 'multictr.simple'
source_filename = "test-cases"

declare i8* @wybe_malloc(i32) local_unnamed_addr

; Function Attrs: norecurse nounwind readnone
define i64* @"multictr.simple.=<0>"(i64* readnone returned %"in#0") local_unnamed_addr #0 {
entry:
  ret i64* %"in#0"
}

; Function Attrs: norecurse nounwind readnone
define i64* @"multictr.simple.=<1>"(i64* readnone returned %"in#0") local_unnamed_addr #0 {
entry:
  ret i64* %"in#0"
}

; Function Attrs: norecurse nounwind readonly
define i1 @"multictr.simple.=<2>"(i64* %"$left#0", i64* %"$right#0") local_unnamed_addr #1 {
entry:
  %"tmp$1#0" = icmp eq i64* %"$left#0", null
  br i1 %"tmp$1#0", label %if.then, label %if.then1

if.then:                                          ; preds = %entry
  %"$$#0" = icmp eq i64* %"$right#0", null
  ret i1 %"$$#0"

if.then1:                                         ; preds = %entry
  %0 = ptrtoint i64* %"$left#0" to i64
  %trunc = trunc i64 %0 to i3
  switch i3 %trunc, label %if.else3 [
    i3 0, label %if.then2
    i3 1, label %if.then6
  ]

if.then2:                                         ; preds = %if.then1
  %1 = load i64, i64* %"$left#0", align 4
  %"tmp$16#0" = icmp eq i64* %"$right#0", null
  br i1 %"tmp$16#0", label %if.else3, label %if.then3

if.then3:                                         ; preds = %if.then2
  %2 = ptrtoint i64* %"$right#0" to i64
  %"tmp$17#0" = and i64 %2, 7
  %"tmp$18#0" = icmp eq i64 %"tmp$17#0", 0
  br i1 %"tmp$18#0", label %if.then4, label %if.else3

if.else3:                                         ; preds = %if.then2, %if.then6, %if.then1, %if.then7, %if.then3
  ret i1 false

if.then4:                                         ; preds = %if.then3
  %3 = load i64, i64* %"$right#0", align 4
  %"$$#01" = icmp eq i64 %1, %3
  ret i1 %"$$#01"

if.then6:                                         ; preds = %if.then1
  %4 = load i64, i64* %"$left#0", align 4
  %"tmp$21#0" = icmp eq i64* %"$right#0", null
  br i1 %"tmp$21#0", label %if.else3, label %if.then7

if.then7:                                         ; preds = %if.then6
  %5 = ptrtoint i64* %"$right#0" to i64
  %"tmp$22#0" = and i64 %5, 7
  %"tmp$23#0" = icmp eq i64 %"tmp$22#0", 1
  br i1 %"tmp$23#0", label %if.then8, label %if.else3

if.then8:                                         ; preds = %if.then7
  %6 = load i64, i64* %"$right#0", align 4
  %"$$#04" = icmp eq i64 %4, %6
  ret i1 %"$$#04"
}

define i64* @"multictr.simple.one<0>"(i64 %"one_field#0") local_unnamed_addr {
entry:
  %0 = tail call i8* @wybe_malloc(i32 8)
  %1 = bitcast i8* %0 to i64*
  store i64 %"one_field#0", i64* %1, align 4
  ret i64* %1
}

; Function Attrs: norecurse nounwind readnone
define { i64, i1 } @"multictr.simple.one<1>"(i64* %"$#0") local_unnamed_addr #0 {
entry:
  %"tmp$1#0" = icmp eq i64* %"$#0", null
  br i1 %"tmp$1#0", label %if.else, label %if.then

if.then:                                          ; preds = %entry
  %0 = ptrtoint i64* %"$#0" to i64
  %"tmp$2#0" = and i64 %0, 7
  %"tmp$4#0" = icmp eq i64 %"tmp$2#0", 0
  br label %if.else

if.else:                                          ; preds = %if.then, %entry
  %merge = phi i1 [ false, %entry ], [ %"tmp$4#0", %if.then ]
  ret i1 %merge
}

; Function Attrs: norecurse nounwind readnone
define { i64, i1 } @"multictr.simple.one_field<0>"(i64* %"$rec#0") local_unnamed_addr #0 {
entry:
  %"tmp$1#0" = icmp eq i64* %"$rec#0", null
  br i1 %"tmp$1#0", label %if.else, label %if.then

if.then:                                          ; preds = %entry
  %0 = ptrtoint i64* %"$rec#0" to i64
  %"tmp$2#0" = and i64 %0, 7
  %"tmp$4#0" = icmp eq i64 %"tmp$2#0", 0
  br label %if.else

if.else:                                          ; preds = %if.then, %entry
  %merge = phi i1 [ false, %entry ], [ %"tmp$4#0", %if.then ]
  ret i1 %merge
}

define { i64*, i1 } @"multictr.simple.one_field<1>"(i64* %"$rec#0", i64 %"$field#0") local_unnamed_addr {
entry:
  %"tmp$1#0" = icmp eq i64* %"$rec#0", null
  br i1 %"tmp$1#0", label %if.else, label %if.then

if.then:                                          ; preds = %entry
  %0 = ptrtoint i64* %"$rec#0" to i64
  %"tmp$2#0" = and i64 %0, 7
  %"tmp$4#0" = icmp eq i64 %"tmp$2#0", 0
  br i1 %"tmp$4#0", label %if.then1, label %if.else

if.else:                                          ; preds = %if.then, %entry
  ret i1 false

if.then1:                                         ; preds = %if.then
  %1 = tail call i8* @wybe_malloc(i32 8)
  store i64 %"$field#0", i64* %"$rec#0", align 4
  ret i1 true
}

define nonnull i64* @"multictr.simple.two<0>"(i64 %"two_field#0") local_unnamed_addr {
entry:
  %0 = tail call i8* @wybe_malloc(i32 8)
  %1 = bitcast i8* %0 to i64*
  store i64 %"two_field#0", i64* %1, align 4
  %2 = ptrtoint i8* %0 to i64
  %"$recinttagged#0" = or i64 %2, 1
  %3 = inttoptr i64 %"$recinttagged#0" to i64*
  ret i64* %3
}

; Function Attrs: norecurse nounwind readnone
define { i64, i1 } @"multictr.simple.two<1>"(i64* %"$#0") local_unnamed_addr #0 {
entry:
  %"tmp$1#0" = icmp eq i64* %"$#0", null
  br i1 %"tmp$1#0", label %if.else, label %if.then

if.then:                                          ; preds = %entry
  %0 = ptrtoint i64* %"$#0" to i64
  %"tmp$2#0" = and i64 %0, 7
  %"tmp$4#0" = icmp eq i64 %"tmp$2#0", 1
  br label %if.else

if.else:                                          ; preds = %if.then, %entry
  %merge = phi i1 [ false, %entry ], [ %"tmp$4#0", %if.then ]
  ret i1 %merge
}

; Function Attrs: norecurse nounwind readnone
define { i64, i1 } @"multictr.simple.two_field<0>"(i64* %"$rec#0") local_unnamed_addr #0 {
entry:
  %"tmp$1#0" = icmp eq i64* %"$rec#0", null
  br i1 %"tmp$1#0", label %if.else, label %if.then

if.then:                                          ; preds = %entry
  %0 = ptrtoint i64* %"$rec#0" to i64
  %"tmp$2#0" = and i64 %0, 7
  %"tmp$4#0" = icmp eq i64 %"tmp$2#0", 1
  br label %if.else

if.else:                                          ; preds = %if.then, %entry
  %merge = phi i1 [ false, %entry ], [ %"tmp$4#0", %if.then ]
  ret i1 %merge
}

define { i64*, i1 } @"multictr.simple.two_field<1>"(i64* %"$rec#0", i64 %"$field#0") local_unnamed_addr {
entry:
  %"tmp$1#0" = icmp eq i64* %"$rec#0", null
  br i1 %"tmp$1#0", label %if.else, label %if.then

if.then:                                          ; preds = %entry
  %0 = ptrtoint i64* %"$rec#0" to i64
  %"tmp$2#0" = and i64 %0, 7
  %"tmp$4#0" = icmp eq i64 %"tmp$2#0", 1
  br i1 %"tmp$4#0", label %if.then1, label %if.else

if.else:                                          ; preds = %if.then, %entry
  ret i1 false

if.then1:                                         ; preds = %if.then
  %1 = tail call i8* @wybe_malloc(i32 8)
  store i64 %"$field#0", i64* %"$rec#0", align 4
  ret i1 true
}

; Function Attrs: norecurse nounwind readnone
define noalias i64* @"multictr.simple.zero<0>"() local_unnamed_addr #0 {
entry:
  ret i64* null
}

attributes #0 = { norecurse nounwind readnone }
attributes #1 = { norecurse nounwind readonly }

