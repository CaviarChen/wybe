======================================================================
AFTER EVERYTHING:
 Module multictr
  public submods  : 
  public types    : number: (multictr.number,"pointer")
                    simple: (multictr.simple,"pointer")
  public resources: 
  public procs    : multictr.number.=<0>
                    multictr.number.float<0>
                    multictr.number.float<1>
                    multictr.number.float_value<0>
                    multictr.number.float_value<1>
                    multictr.number.int<0>
                    multictr.number.int<1>
                    multictr.number.int_value<0>
                    multictr.number.int_value<1>
                    multictr.simple.=<0>
                    multictr.simple.one<0>
                    multictr.simple.one<1>
                    multictr.simple.one_field<0>
                    multictr.simple.one_field<1>
                    multictr.simple.two<0>
                    multictr.simple.two<1>
                    multictr.simple.two_field<0>
                    multictr.simple.two_field<1>
                    multictr.simple.zero<0>
  imports         : public use multictr.number
                    public use multictr.simple
                    use wybe
  types           : number/0 (pointer)  @multictr:3:8, simple/0 (pointer)  @multictr:8:8
  resources       : 
  submodules      : multictr.number, multictr.simple
  procs           : 


  LLVM code       :

; ModuleID = 'multictr'


declare external ccc i8* @wybe_malloc(i32)

declare external ccc void @llvm.memcpy.p0i8.p0i8.i32(i8*, i8*, i32, i1)
--------------------------------------------------
 Module multictr.number([])
  public submods  : 
  public types    : 
  public resources: 
  public procs    : multictr.number.=<0>
                    multictr.number.float<0>
                    multictr.number.float<1>
                    multictr.number.float_value<0>
                    multictr.number.float_value<1>
                    multictr.number.int<0>
                    multictr.number.int<1>
                    multictr.number.int_value<0>
                    multictr.number.int_value<1>
  imports         : use multictr
                    use wybe
  types           : 
  resources       : 
  procs           : 

= > public test (2 calls)
0: =($left#0:multictr.number, $right#0:multictr.number, ?$$#0:wybe.bool): AliasPairs: []
    foreign lpvm cast($left#0:multictr.number, ?tmp$0#0:wybe.int)
    foreign llvm and(~tmp$0#0:wybe.int, 7:wybe.int, ?tmp$10#0:wybe.int)
    foreign llvm icmp eq(tmp$10#0:wybe.int, 0:wybe.int, ?tmp$11#0:wybe.bool)
    case ~tmp$11#0:wybe.bool of
    0:
        foreign llvm icmp eq(~tmp$10#0:wybe.int, 1:wybe.int, ?tmp$15#0:wybe.bool)
        case ~tmp$15#0:wybe.bool of
        0:
            foreign llvm move(0:wybe.bool, ?$$#0:wybe.bool)

        1:
            foreign lpvm access(~$left#0:multictr.number, -1:wybe.int, ?$left$float_value#0:wybe.float)
            foreign lpvm cast($right#0:multictr.number, ?tmp$17#0:wybe.int)
            foreign llvm and(~tmp$17#0:wybe.int, 7:wybe.int, ?tmp$18#0:wybe.int)
            foreign llvm icmp eq(~tmp$18#0:wybe.int, 1:wybe.int, ?tmp$19#0:wybe.bool)
            case ~tmp$19#0:wybe.bool of
            0:
                foreign llvm move(0:wybe.bool, ?$$#0:wybe.bool)

            1:
                foreign lpvm access(~$right#0:multictr.number, -1:wybe.int, ?$right$float_value#0:wybe.float)
                foreign llvm fcmp eq(~$left$float_value#0:wybe.float, ~$right$float_value#0:wybe.float, ?$$#0:wybe.bool) @wybe:nn:nn



    1:
        foreign lpvm access($left#0:multictr.number, 0:wybe.int, ?$left$int_value#0:wybe.int)
        foreign lpvm cast($right#0:multictr.number, ?tmp$13#0:wybe.int)
        foreign llvm and(~tmp$13#0:wybe.int, 7:wybe.int, ?tmp$14#0:wybe.int)
        foreign llvm icmp eq(~tmp$14#0:wybe.int, 0:wybe.int, ?tmp$15#0:wybe.bool)
        case ~tmp$15#0:wybe.bool of
        0:
            foreign llvm move(0:wybe.bool, ?$$#0:wybe.bool)

        1:
            foreign lpvm access(~$right#0:multictr.number, 0:wybe.int, ?$right$int_value#0:wybe.int)
            foreign llvm icmp eq(~$left$int_value#0:wybe.int, ~$right$int_value#0:wybe.int, ?$$#0:wybe.bool) @wybe:nn:nn




float > public inline (0 calls)
0: float(float_value#0:wybe.float, ?$#0:multictr.number): AliasPairs: []
    foreign lpvm alloc(8:wybe.int, ?$rec#0:multictr.number)
    foreign lpvm mutate(~%$rec#0:multictr.number, ?%$rec#1:multictr.number, 8:wybe.int, 0:wybe.int, 1:wybe.int, ~float_value#0:wybe.float)
    foreign lpvm cast(~$rec#1:multictr.number, ?$recint#0:wybe.int)
    foreign llvm or(~$recint#0, 1:wybe.int, ?$recinttagged#0:wybe.int)
    foreign lpvm cast(~$recinttagged#0, ?$#0:multictr.number)
float > public inline test (5 calls)
1: float(?float_value#0:wybe.float, $#0:multictr.number, ?$$#0:wybe.bool): AliasPairs: []
    foreign lpvm cast($#0:multictr.number, ?tmp$1#0:wybe.int)
    foreign llvm and(~tmp$1#0:wybe.int, 7:wybe.int, ?tmp$0#0:wybe.int)
    foreign llvm icmp eq(~tmp$0#0:wybe.int, 1:wybe.int, ?tmp$2#0:wybe.bool)
    case ~tmp$2#0:wybe.bool of
    0:
        foreign llvm move(0:wybe.bool, ?$$#0:wybe.bool)

    1:
        foreign lpvm access(~$#0:multictr.number, -1:wybe.int, ?float_value#0:wybe.float)
        foreign llvm move(1:wybe.bool, ?$$#0:wybe.bool)



float_value > public inline test (0 calls)
0: float_value($rec#0:multictr.number, ?$#0:wybe.float, ?$$#0:wybe.bool): AliasPairs: []
    foreign lpvm cast($rec#0:multictr.number, ?tmp$1#0:wybe.int)
    foreign llvm and(~tmp$1#0:wybe.int, 7:wybe.int, ?tmp$0#0:wybe.int)
    foreign llvm icmp eq(~tmp$0#0:wybe.int, 1:wybe.int, ?tmp$2#0:wybe.bool)
    case ~tmp$2#0:wybe.bool of
    0:
        foreign llvm move(0:wybe.bool, ?$$#0:wybe.bool)

    1:
        foreign lpvm access(~$rec#0:multictr.number, -1:wybe.int, ?$#0:wybe.float)
        foreign llvm move(1:wybe.bool, ?$$#0:wybe.bool)

float_value > public inline test (0 calls)
1: float_value($rec#0:multictr.number, ?$rec#1:multictr.number, $field#0:wybe.float, ?$$#0:wybe.bool): AliasPairs: []
    foreign lpvm cast($rec#0:multictr.number, ?tmp$1#0:wybe.int)
    foreign llvm and(~tmp$1#0:wybe.int, 7:wybe.int, ?tmp$0#0:wybe.int)
    foreign llvm icmp eq(~tmp$0#0:wybe.int, 1:wybe.int, ?tmp$2#0:wybe.bool)
    case ~tmp$2#0:wybe.bool of
    0:
        foreign llvm move(0:wybe.bool, ?$$#0:wybe.bool)
        foreign llvm move(~$rec#0:multictr.number, ?$rec#1:multictr.number)

    1:
        foreign lpvm mutate(~%$rec#0:multictr.number, ?%$rec#1:multictr.number, 8:wybe.int, -1:wybe.int, 0:wybe.int, ~$field#0:wybe.float)
        foreign llvm move(1:wybe.bool, ?$$#0:wybe.bool)



int > public inline (0 calls)
0: int(int_value#0:wybe.int, ?$#0:multictr.number): AliasPairs: []
    foreign lpvm alloc(8:wybe.int, ?$rec#0:multictr.number)
    foreign lpvm mutate(~%$rec#0:multictr.number, ?%$#0:multictr.number, 8:wybe.int, 0:wybe.int, 1:wybe.int, ~int_value#0:wybe.int)
int > public inline test (7 calls)
1: int(?int_value#0:wybe.int, $#0:multictr.number, ?$$#0:wybe.bool): AliasPairs: []
    foreign lpvm cast($#0:multictr.number, ?tmp$1#0:wybe.int)
    foreign llvm and(~tmp$1#0:wybe.int, 7:wybe.int, ?tmp$0#0:wybe.int)
    foreign llvm icmp eq(~tmp$0#0:wybe.int, 0:wybe.int, ?tmp$2#0:wybe.bool)
    case ~tmp$2#0:wybe.bool of
    0:
        foreign llvm move(0:wybe.bool, ?$$#0:wybe.bool)

    1:
        foreign lpvm access(~$#0:multictr.number, 0:wybe.int, ?int_value#0:wybe.int)
        foreign llvm move(1:wybe.bool, ?$$#0:wybe.bool)



int_value > public inline test (0 calls)
0: int_value($rec#0:multictr.number, ?$#0:wybe.int, ?$$#0:wybe.bool): AliasPairs: []
    foreign lpvm cast($rec#0:multictr.number, ?tmp$1#0:wybe.int)
    foreign llvm and(~tmp$1#0:wybe.int, 7:wybe.int, ?tmp$0#0:wybe.int)
    foreign llvm icmp eq(~tmp$0#0:wybe.int, 0:wybe.int, ?tmp$2#0:wybe.bool)
    case ~tmp$2#0:wybe.bool of
    0:
        foreign llvm move(0:wybe.bool, ?$$#0:wybe.bool)

    1:
        foreign lpvm access(~$rec#0:multictr.number, 0:wybe.int, ?$#0:wybe.int)
        foreign llvm move(1:wybe.bool, ?$$#0:wybe.bool)

int_value > public inline test (0 calls)
1: int_value($rec#0:multictr.number, ?$rec#1:multictr.number, $field#0:wybe.int, ?$$#0:wybe.bool): AliasPairs: []
    foreign lpvm cast($rec#0:multictr.number, ?tmp$1#0:wybe.int)
    foreign llvm and(~tmp$1#0:wybe.int, 7:wybe.int, ?tmp$0#0:wybe.int)
    foreign llvm icmp eq(~tmp$0#0:wybe.int, 0:wybe.int, ?tmp$2#0:wybe.bool)
    case ~tmp$2#0:wybe.bool of
    0:
        foreign llvm move(0:wybe.bool, ?$$#0:wybe.bool)
        foreign llvm move(~$rec#0:multictr.number, ?$rec#1:multictr.number)

    1:
        foreign lpvm mutate(~%$rec#0:multictr.number, ?%$rec#1:multictr.number, 8:wybe.int, 0:wybe.int, 0:wybe.int, ~$field#0:wybe.int)
        foreign llvm move(1:wybe.bool, ?$$#0:wybe.bool)


  LLVM code       :

; ModuleID = 'multictr.number'


declare external ccc i8* @wybe_malloc(i32)

declare external ccc void @llvm.memcpy.p0i8.p0i8.i32(i8*, i8*, i32, i1)

define external ccc i1 @"multictr.number.=<0>"(i64* %"$left#0", i64* %"$right#0"){
entry:
  %1 = ptrtoint i64* %"$left#0" to i64
  %"tmp$10#0" = and i64 %1, 7
  %"tmp$11#0" = icmp eq i64 %"tmp$10#0", 0
  br i1 %"tmp$11#0", label %if.then, label %if.else
if.then:
  %2 = bitcast i64* %"$left#0" to i64*
  %3 = getelementptr i64, i64* %2, i64 0
  %4 = load i64, i64* %3
  %5 = ptrtoint i64* %"$right#0" to i64
  %"tmp$14#0" = and i64 %5, 7
  %"tmp$15#0" = icmp eq i64 %"tmp$14#0", 0
  br i1 %"tmp$15#0", label %if.then1, label %if.else1
if.else:
  %"tmp$15#0" = icmp eq i64 %"tmp$10#0", 1
  br i1 %"tmp$15#0", label %if.then2, label %if.else2
if.then1:
  %6 = bitcast i64* %"$right#0" to i64*
  %7 = getelementptr i64, i64* %6, i64 0
  %8 = load i64, i64* %7
  %"$$#0" = icmp eq i64 %4, %8
  ret i1 %"$$#0"
if.else1:
  ret i1 %"tmp$15#0"
if.then2:
  %9 = bitcast i64* %"$left#0" to double*
  %10 = getelementptr double, double* %9, i64 0
  %11 = load double, double* %10
  %12 = ptrtoint i64* %"$right#0" to i64
  %"tmp$18#0" = and i64 %12, 7
  %"tmp$19#0" = icmp eq i64 %"tmp$18#0", 1
  br i1 %"tmp$19#0", label %if.then3, label %if.else3
if.else2:
  ret i1 %"tmp$15#0"
if.then3:
  %13 = bitcast i64* %"$right#0" to double*
  %14 = getelementptr double, double* %13, i64 0
  %15 = load double, double* %14
  %"$$#0" = fcmp oeq double %11, %15
  ret i1 %"$$#0"
if.else3:
  ret i1 %"tmp$19#0"
}

define external ccc i64* @"multictr.number.float<0>"(double %"float_value#0"){
entry:
  %16 = tail call ccc i8* @wybe_malloc(i32 8)
  %17 = bitcast i8* %16 to i64*
  %18 = bitcast i64* %17 to double*
  %19 = getelementptr double, double* %18, i64 0
  store double %"float_value#0", double* %19
  %20 = ptrtoint i64* %17 to i64
  %"$recinttagged#0" = or i64 %20, 1
  %21 = inttoptr i64 %"$recinttagged#0" to i64*
  ret i64* %21
}

define external ccc {double, i1} @"multictr.number.float<1>"(i64* %"$#0"){
entry:
  %22 = ptrtoint i64* %"$#0" to i64
  %"tmp$0#0" = and i64 %22, 7
  %"tmp$2#0" = icmp eq i64 %"tmp$0#0", 1
  br i1 %"tmp$2#0", label %if.then, label %if.else
if.then:
  %23 = bitcast i64* %"$#0" to double*
  %24 = getelementptr double, double* %23, i64 0
  %25 = load double, double* %24
  %26 = insertvalue {double, i1} undef, double %25, 0
  %27 = insertvalue {double, i1} %26, i1 1, 1
  ret i1 1
if.else:
  %28 = insertvalue {double, i1} undef, double %25, 0
  %29 = insertvalue {double, i1} %28, i1 0, 1
  ret i1 0
}

define external ccc {double, i1} @"multictr.number.float_value<0>"(i64* %"$rec#0"){
entry:
  %30 = ptrtoint i64* %"$rec#0" to i64
  %"tmp$0#0" = and i64 %30, 7
  %"tmp$2#0" = icmp eq i64 %"tmp$0#0", 1
  br i1 %"tmp$2#0", label %if.then, label %if.else
if.then:
  %31 = bitcast i64* %"$rec#0" to double*
  %32 = getelementptr double, double* %31, i64 0
  %33 = load double, double* %32
  %34 = insertvalue {double, i1} undef, double %33, 0
  %35 = insertvalue {double, i1} %34, i1 1, 1
  ret i1 1
if.else:
  %36 = insertvalue {double, i1} undef, double %33, 0
  %37 = insertvalue {double, i1} %36, i1 0, 1
  ret i1 0
}

define external ccc {i64*, i1} @"multictr.number.float_value<1>"(i64* %"$rec#0", double %"$field#0"){
entry:
  %38 = ptrtoint i64* %"$rec#0" to i64
  %"tmp$0#0" = and i64 %38, 7
  %"tmp$2#0" = icmp eq i64 %"tmp$0#0", 1
  br i1 %"tmp$2#0", label %if.then, label %if.else
if.then:
  %39 = tail call ccc i8* @wybe_malloc(i32 8)
  %40 = bitcast i8* %39 to i64*
  %41 = bitcast i64* %40 to i8*
  %42 = bitcast i64* %"$rec#0" to i8*
  tail call ccc void @llvm.memcpy.p0i8.p0i8.i32(i8* %41, i8* %42, i32 8, i1 0)
  %43 = bitcast i64* %40 to double*
  %44 = getelementptr double, double* %43, i64 0
  store double %"$field#0", double* %44
  %45 = insertvalue {i64*, i1} undef, i64* %40, 0
  %46 = insertvalue {i64*, i1} %45, i1 1, 1
  ret i1 1
if.else:
  %47 = insertvalue {i64*, i1} undef, i64* %"$rec#0", 0
  %48 = insertvalue {i64*, i1} %47, i1 0, 1
  ret i64* %"$rec#0"
}

define external ccc i64* @"multictr.number.int<0>"(i64 %"int_value#0"){
entry:
  %49 = tail call ccc i8* @wybe_malloc(i32 8)
  %50 = bitcast i8* %49 to i64*
  %51 = bitcast i64* %50 to i64*
  %52 = getelementptr i64, i64* %51, i64 0
  store i64 %"int_value#0", i64* %52
  ret i64* %50
}

define external ccc {i64, i1} @"multictr.number.int<1>"(i64* %"$#0"){
entry:
  %53 = ptrtoint i64* %"$#0" to i64
  %"tmp$0#0" = and i64 %53, 7
  %"tmp$2#0" = icmp eq i64 %"tmp$0#0", 0
  br i1 %"tmp$2#0", label %if.then, label %if.else
if.then:
  %54 = bitcast i64* %"$#0" to i64*
  %55 = getelementptr i64, i64* %54, i64 0
  %56 = load i64, i64* %55
  %57 = insertvalue {i64, i1} undef, i64 %56, 0
  %58 = insertvalue {i64, i1} %57, i1 1, 1
  ret i1 1
if.else:
  %59 = insertvalue {i64, i1} undef, i64 %56, 0
  %60 = insertvalue {i64, i1} %59, i1 0, 1
  ret i1 0
}

define external ccc {i64, i1} @"multictr.number.int_value<0>"(i64* %"$rec#0"){
entry:
  %61 = ptrtoint i64* %"$rec#0" to i64
  %"tmp$0#0" = and i64 %61, 7
  %"tmp$2#0" = icmp eq i64 %"tmp$0#0", 0
  br i1 %"tmp$2#0", label %if.then, label %if.else
if.then:
  %62 = bitcast i64* %"$rec#0" to i64*
  %63 = getelementptr i64, i64* %62, i64 0
  %64 = load i64, i64* %63
  %65 = insertvalue {i64, i1} undef, i64 %64, 0
  %66 = insertvalue {i64, i1} %65, i1 1, 1
  ret i1 1
if.else:
  %67 = insertvalue {i64, i1} undef, i64 %64, 0
  %68 = insertvalue {i64, i1} %67, i1 0, 1
  ret i1 0
}

define external ccc {i64*, i1} @"multictr.number.int_value<1>"(i64* %"$rec#0", i64 %"$field#0"){
entry:
  %69 = ptrtoint i64* %"$rec#0" to i64
  %"tmp$0#0" = and i64 %69, 7
  %"tmp$2#0" = icmp eq i64 %"tmp$0#0", 0
  br i1 %"tmp$2#0", label %if.then, label %if.else
if.then:
  %70 = tail call ccc i8* @wybe_malloc(i32 8)
  %71 = bitcast i8* %70 to i64*
  %72 = bitcast i64* %71 to i8*
  %73 = bitcast i64* %"$rec#0" to i8*
  tail call ccc void @llvm.memcpy.p0i8.p0i8.i32(i8* %72, i8* %73, i32 8, i1 0)
  %74 = bitcast i64* %71 to i64*
  %75 = getelementptr i64, i64* %74, i64 0
  store i64 %"$field#0", i64* %75
  %76 = insertvalue {i64*, i1} undef, i64* %71, 0
  %77 = insertvalue {i64*, i1} %76, i1 1, 1
  ret i1 1
if.else:
  %78 = insertvalue {i64*, i1} undef, i64* %"$rec#0", 0
  %79 = insertvalue {i64*, i1} %78, i1 0, 1
  ret i64* %"$rec#0"
}
--------------------------------------------------
 Module multictr.simple([])
  public submods  : 
  public types    : 
  public resources: 
  public procs    : multictr.simple.=<0>
                    multictr.simple.one<0>
                    multictr.simple.one<1>
                    multictr.simple.one_field<0>
                    multictr.simple.one_field<1>
                    multictr.simple.two<0>
                    multictr.simple.two<1>
                    multictr.simple.two_field<0>
                    multictr.simple.two_field<1>
                    multictr.simple.zero<0>
  imports         : use multictr
                    use wybe
  types           : 
  resources       : 
  procs           : 

= > public test (2 calls)
0: =($left#0:multictr.simple, $right#0:multictr.simple, ?$$#0:wybe.bool): AliasPairs: []
    foreign lpvm cast($left#0:multictr.simple, ?tmp$0#0:wybe.int)
    foreign llvm icmp eq(tmp$0#0:wybe.int, 0:wybe.int, ?tmp$1#0:wybe.bool)
    case ~tmp$1#0:wybe.bool of
    0:
        foreign llvm icmp ne(tmp$0#0:wybe.int, 0:wybe.int, ?tmp$11#0:wybe.bool)
        case tmp$11#0:wybe.bool of
        0:
            case ~tmp$11#0:wybe.bool of
            0:
                foreign llvm move(0:wybe.bool, ?$$#0:wybe.bool)

            1:
                foreign llvm and(~tmp$0#0:wybe.int, 7:wybe.int, ?tmp$17#0:wybe.int)
                foreign llvm icmp eq(~tmp$17#0:wybe.int, 1:wybe.int, ?tmp$18#0:wybe.bool)
                case ~tmp$18#0:wybe.bool of
                0:
                    foreign llvm move(0:wybe.bool, ?$$#0:wybe.bool)

                1:
                    foreign lpvm access(~$left#0:multictr.simple, -1:wybe.int, ?$left$two_field#0:wybe.int)
                    foreign lpvm cast($right#0:multictr.simple, ?tmp$20#0:wybe.int)
                    foreign llvm icmp ne(tmp$20#0:wybe.int, 0:wybe.int, ?tmp$21#0:wybe.bool)
                    case ~tmp$21#0:wybe.bool of
                    0:
                        foreign llvm move(0:wybe.bool, ?$$#0:wybe.bool)

                    1:
                        foreign llvm and(~tmp$20#0:wybe.int, 7:wybe.int, ?tmp$22#0:wybe.int)
                        foreign llvm icmp eq(~tmp$22#0:wybe.int, 1:wybe.int, ?tmp$23#0:wybe.bool)
                        case ~tmp$23#0:wybe.bool of
                        0:
                            foreign llvm move(0:wybe.bool, ?$$#0:wybe.bool)

                        1:
                            foreign lpvm access(~$right#0:multictr.simple, -1:wybe.int, ?$right$two_field#0:wybe.int)
                            foreign llvm icmp eq(~$left$two_field#0:wybe.int, ~$right$two_field#0:wybe.int, ?$$#0:wybe.bool) @wybe:nn:nn





        1:
            foreign llvm and(tmp$0#0:wybe.int, 7:wybe.int, ?tmp$12#0:wybe.int)
            foreign llvm icmp eq(~tmp$12#0:wybe.int, 0:wybe.int, ?tmp$13#0:wybe.bool)
            case ~tmp$13#0:wybe.bool of
            0:
                case ~tmp$11#0:wybe.bool of
                0:
                    foreign llvm move(0:wybe.bool, ?$$#0:wybe.bool)

                1:
                    foreign llvm and(~tmp$0#0:wybe.int, 7:wybe.int, ?tmp$17#0:wybe.int)
                    foreign llvm icmp eq(~tmp$17#0:wybe.int, 1:wybe.int, ?tmp$18#0:wybe.bool)
                    case ~tmp$18#0:wybe.bool of
                    0:
                        foreign llvm move(0:wybe.bool, ?$$#0:wybe.bool)

                    1:
                        foreign lpvm access(~$left#0:multictr.simple, -1:wybe.int, ?$left$two_field#0:wybe.int)
                        foreign lpvm cast($right#0:multictr.simple, ?tmp$20#0:wybe.int)
                        foreign llvm icmp ne(tmp$20#0:wybe.int, 0:wybe.int, ?tmp$21#0:wybe.bool)
                        case ~tmp$21#0:wybe.bool of
                        0:
                            foreign llvm move(0:wybe.bool, ?$$#0:wybe.bool)

                        1:
                            foreign llvm and(~tmp$20#0:wybe.int, 7:wybe.int, ?tmp$22#0:wybe.int)
                            foreign llvm icmp eq(~tmp$22#0:wybe.int, 1:wybe.int, ?tmp$23#0:wybe.bool)
                            case ~tmp$23#0:wybe.bool of
                            0:
                                foreign llvm move(0:wybe.bool, ?$$#0:wybe.bool)

                            1:
                                foreign lpvm access(~$right#0:multictr.simple, -1:wybe.int, ?$right$two_field#0:wybe.int)
                                foreign llvm icmp eq(~$left$two_field#0:wybe.int, ~$right$two_field#0:wybe.int, ?$$#0:wybe.bool) @wybe:nn:nn





            1:
                foreign lpvm access($left#0:multictr.simple, 0:wybe.int, ?$left$one_field#0:wybe.int)
                foreign lpvm cast($right#0:multictr.simple, ?tmp$15#0:wybe.int)
                foreign llvm icmp ne(tmp$15#0:wybe.int, 0:wybe.int, ?tmp$16#0:wybe.bool)
                case ~tmp$16#0:wybe.bool of
                0:
                    foreign llvm move(0:wybe.bool, ?$$#0:wybe.bool)

                1:
                    foreign llvm and(~tmp$15#0:wybe.int, 7:wybe.int, ?tmp$17#0:wybe.int)
                    foreign llvm icmp eq(~tmp$17#0:wybe.int, 0:wybe.int, ?tmp$18#0:wybe.bool)
                    case ~tmp$18#0:wybe.bool of
                    0:
                        foreign llvm move(0:wybe.bool, ?$$#0:wybe.bool)

                    1:
                        foreign lpvm access(~$right#0:multictr.simple, 0:wybe.int, ?$right$one_field#0:wybe.int)
                        foreign llvm icmp eq(~$left$one_field#0:wybe.int, ~$right$one_field#0:wybe.int, ?$$#0:wybe.bool) @wybe:nn:nn





    1:
        foreign llvm icmp eq(~$left#0:wybe.int, ~$right#0:wybe.int, ?$$#0:wybe.bool)



one > public inline (0 calls)
0: one(one_field#0:wybe.int, ?$#0:multictr.simple): AliasPairs: []
    foreign lpvm alloc(8:wybe.int, ?$rec#0:multictr.simple)
    foreign lpvm mutate(~%$rec#0:multictr.simple, ?%$#0:multictr.simple, 8:wybe.int, 0:wybe.int, 1:wybe.int, ~one_field#0:wybe.int)
one > public inline test (7 calls)
1: one(?one_field#0:wybe.int, $#0:multictr.simple, ?$$#0:wybe.bool): AliasPairs: []
    foreign lpvm cast($#0:multictr.simple, ?tmp$0#0:wybe.int)
    foreign llvm icmp ne(tmp$0#0:wybe.int, 0:wybe.int, ?tmp$1#0:wybe.bool)
    case ~tmp$1#0:wybe.bool of
    0:
        foreign llvm move(0:wybe.bool, ?$$#0:wybe.bool)

    1:
        foreign llvm and(~tmp$0#0:wybe.int, 7:wybe.int, ?tmp$2#0:wybe.int)
        foreign llvm icmp eq(~tmp$2#0:wybe.int, 0:wybe.int, ?tmp$4#0:wybe.bool)
        case ~tmp$4#0:wybe.bool of
        0:
            foreign llvm move(0:wybe.bool, ?$$#0:wybe.bool)

        1:
            foreign lpvm access(~$#0:multictr.simple, 0:wybe.int, ?one_field#0:wybe.int)
            foreign llvm move(1:wybe.bool, ?$$#0:wybe.bool)




one_field > public inline test (0 calls)
0: one_field($rec#0:multictr.simple, ?$#0:wybe.int, ?$$#0:wybe.bool): AliasPairs: []
    foreign lpvm cast($rec#0:multictr.simple, ?tmp$0#0:wybe.int)
    foreign llvm icmp ne(tmp$0#0:wybe.int, 0:wybe.int, ?tmp$1#0:wybe.bool)
    case ~tmp$1#0:wybe.bool of
    0:
        foreign llvm move(0:wybe.bool, ?$$#0:wybe.bool)

    1:
        foreign llvm and(~tmp$0#0:wybe.int, 7:wybe.int, ?tmp$2#0:wybe.int)
        foreign llvm icmp eq(~tmp$2#0:wybe.int, 0:wybe.int, ?tmp$4#0:wybe.bool)
        case ~tmp$4#0:wybe.bool of
        0:
            foreign llvm move(0:wybe.bool, ?$$#0:wybe.bool)

        1:
            foreign lpvm access(~$rec#0:multictr.simple, 0:wybe.int, ?$#0:wybe.int)
            foreign llvm move(1:wybe.bool, ?$$#0:wybe.bool)


one_field > public inline test (0 calls)
1: one_field($rec#0:multictr.simple, ?$rec#1:multictr.simple, $field#0:wybe.int, ?$$#0:wybe.bool): AliasPairs: []
    foreign lpvm cast($rec#0:multictr.simple, ?tmp$0#0:wybe.int)
    foreign llvm icmp ne(tmp$0#0:wybe.int, 0:wybe.int, ?tmp$1#0:wybe.bool)
    case ~tmp$1#0:wybe.bool of
    0:
        foreign llvm move(0:wybe.bool, ?$$#0:wybe.bool)
        foreign llvm move(~$rec#0:multictr.simple, ?$rec#1:multictr.simple)

    1:
        foreign llvm and(~tmp$0#0:wybe.int, 7:wybe.int, ?tmp$2#0:wybe.int)
        foreign llvm icmp eq(~tmp$2#0:wybe.int, 0:wybe.int, ?tmp$4#0:wybe.bool)
        case ~tmp$4#0:wybe.bool of
        0:
            foreign llvm move(0:wybe.bool, ?$$#0:wybe.bool)
            foreign llvm move(~$rec#0:multictr.simple, ?$rec#1:multictr.simple)

        1:
            foreign lpvm mutate(~%$rec#0:multictr.simple, ?%$rec#1:multictr.simple, 8:wybe.int, 0:wybe.int, 0:wybe.int, ~$field#0:wybe.int)
            foreign llvm move(1:wybe.bool, ?$$#0:wybe.bool)




two > public inline (0 calls)
0: two(two_field#0:wybe.int, ?$#0:multictr.simple): AliasPairs: []
    foreign lpvm alloc(8:wybe.int, ?$rec#0:multictr.simple)
    foreign lpvm mutate(~%$rec#0:multictr.simple, ?%$rec#1:multictr.simple, 8:wybe.int, 0:wybe.int, 1:wybe.int, ~two_field#0:wybe.int)
    foreign lpvm cast(~$rec#1:multictr.simple, ?$recint#0:wybe.int)
    foreign llvm or(~$recint#0, 1:wybe.int, ?$recinttagged#0:wybe.int)
    foreign lpvm cast(~$recinttagged#0, ?$#0:multictr.simple)
two > public inline test (5 calls)
1: two(?two_field#0:wybe.int, $#0:multictr.simple, ?$$#0:wybe.bool): AliasPairs: []
    foreign lpvm cast($#0:multictr.simple, ?tmp$0#0:wybe.int)
    foreign llvm icmp ne(tmp$0#0:wybe.int, 0:wybe.int, ?tmp$1#0:wybe.bool)
    case ~tmp$1#0:wybe.bool of
    0:
        foreign llvm move(0:wybe.bool, ?$$#0:wybe.bool)

    1:
        foreign llvm and(~tmp$0#0:wybe.int, 7:wybe.int, ?tmp$2#0:wybe.int)
        foreign llvm icmp eq(~tmp$2#0:wybe.int, 1:wybe.int, ?tmp$4#0:wybe.bool)
        case ~tmp$4#0:wybe.bool of
        0:
            foreign llvm move(0:wybe.bool, ?$$#0:wybe.bool)

        1:
            foreign lpvm access(~$#0:multictr.simple, -1:wybe.int, ?two_field#0:wybe.int)
            foreign llvm move(1:wybe.bool, ?$$#0:wybe.bool)




two_field > public inline test (0 calls)
0: two_field($rec#0:multictr.simple, ?$#0:wybe.int, ?$$#0:wybe.bool): AliasPairs: []
    foreign lpvm cast($rec#0:multictr.simple, ?tmp$0#0:wybe.int)
    foreign llvm icmp ne(tmp$0#0:wybe.int, 0:wybe.int, ?tmp$1#0:wybe.bool)
    case ~tmp$1#0:wybe.bool of
    0:
        foreign llvm move(0:wybe.bool, ?$$#0:wybe.bool)

    1:
        foreign llvm and(~tmp$0#0:wybe.int, 7:wybe.int, ?tmp$2#0:wybe.int)
        foreign llvm icmp eq(~tmp$2#0:wybe.int, 1:wybe.int, ?tmp$4#0:wybe.bool)
        case ~tmp$4#0:wybe.bool of
        0:
            foreign llvm move(0:wybe.bool, ?$$#0:wybe.bool)

        1:
            foreign lpvm access(~$rec#0:multictr.simple, -1:wybe.int, ?$#0:wybe.int)
            foreign llvm move(1:wybe.bool, ?$$#0:wybe.bool)


two_field > public inline test (0 calls)
1: two_field($rec#0:multictr.simple, ?$rec#1:multictr.simple, $field#0:wybe.int, ?$$#0:wybe.bool): AliasPairs: []
    foreign lpvm cast($rec#0:multictr.simple, ?tmp$0#0:wybe.int)
    foreign llvm icmp ne(tmp$0#0:wybe.int, 0:wybe.int, ?tmp$1#0:wybe.bool)
    case ~tmp$1#0:wybe.bool of
    0:
        foreign llvm move(0:wybe.bool, ?$$#0:wybe.bool)
        foreign llvm move(~$rec#0:multictr.simple, ?$rec#1:multictr.simple)

    1:
        foreign llvm and(~tmp$0#0:wybe.int, 7:wybe.int, ?tmp$2#0:wybe.int)
        foreign llvm icmp eq(~tmp$2#0:wybe.int, 1:wybe.int, ?tmp$4#0:wybe.bool)
        case ~tmp$4#0:wybe.bool of
        0:
            foreign llvm move(0:wybe.bool, ?$$#0:wybe.bool)
            foreign llvm move(~$rec#0:multictr.simple, ?$rec#1:multictr.simple)

        1:
            foreign lpvm mutate(~%$rec#0:multictr.simple, ?%$rec#1:multictr.simple, 8:wybe.int, -1:wybe.int, 0:wybe.int, ~$field#0:wybe.int)
            foreign llvm move(1:wybe.bool, ?$$#0:wybe.bool)




zero > public inline (0 calls)
0: zero(?$#0:multictr.simple): AliasPairs: []
    foreign llvm move(0:multictr.simple, ?$#0:multictr.simple)

  LLVM code       :

; ModuleID = 'multictr.simple'


declare external ccc i8* @wybe_malloc(i32)

declare external ccc void @llvm.memcpy.p0i8.p0i8.i32(i8*, i8*, i32, i1)

define external ccc i1 @"multictr.simple.=<0>"(i64* %"$left#0", i64* %"$right#0"){
entry:
  %1 = ptrtoint i64* %"$left#0" to i64
  %"tmp$1#0" = icmp eq i64 %1, 0
  br i1 %"tmp$1#0", label %if.then, label %if.else
if.then:
  %"$$#0" = icmp eq i64* %"$left#0", %"$right#0"
  ret i1 %"$$#0"
if.else:
  %"tmp$11#0" = icmp ne i64 %1, 0
  br i1 %"tmp$11#0", label %if.then1, label %if.else1
if.then1:
  %"tmp$12#0" = and i64 %1, 7
  %"tmp$13#0" = icmp eq i64 %"tmp$12#0", 0
  br i1 %"tmp$13#0", label %if.then2, label %if.else2
if.else1:
  br i1 %"tmp$11#0", label %if.then9, label %if.else9
if.then2:
  %2 = bitcast i64* %"$left#0" to i64*
  %3 = getelementptr i64, i64* %2, i64 0
  %4 = load i64, i64* %3
  %5 = ptrtoint i64* %"$right#0" to i64
  %"tmp$16#0" = icmp ne i64 %5, 0
  br i1 %"tmp$16#0", label %if.then3, label %if.else3
if.else2:
  br i1 %"tmp$11#0", label %if.then5, label %if.else5
if.then3:
  %"tmp$17#0" = and i64 %5, 7
  %"tmp$18#0" = icmp eq i64 %"tmp$17#0", 0
  br i1 %"tmp$18#0", label %if.then4, label %if.else4
if.else3:
  ret i1 %"tmp$16#0"
if.then4:
  %6 = bitcast i64* %"$right#0" to i64*
  %7 = getelementptr i64, i64* %6, i64 0
  %8 = load i64, i64* %7
  %"$$#0" = icmp eq i64 %4, %8
  ret i1 %"$$#0"
if.else4:
  ret i1 %"tmp$18#0"
if.then5:
  %"tmp$17#0" = and i64 %1, 7
  %"tmp$18#0" = icmp eq i64 %"tmp$17#0", 1
  br i1 %"tmp$18#0", label %if.then6, label %if.else6
if.else5:
  ret i1 %"tmp$13#0"
if.then6:
  %9 = bitcast i64* %"$left#0" to i64*
  %10 = getelementptr i64, i64* %9, i64 0
  %11 = load i64, i64* %10
  %12 = ptrtoint i64* %"$right#0" to i64
  %"tmp$21#0" = icmp ne i64 %12, 0
  br i1 %"tmp$21#0", label %if.then7, label %if.else7
if.else6:
  ret i1 %"tmp$18#0"
if.then7:
  %"tmp$22#0" = and i64 %12, 7
  %"tmp$23#0" = icmp eq i64 %"tmp$22#0", 1
  br i1 %"tmp$23#0", label %if.then8, label %if.else8
if.else7:
  ret i1 %"tmp$21#0"
if.then8:
  %13 = bitcast i64* %"$right#0" to i64*
  %14 = getelementptr i64, i64* %13, i64 0
  %15 = load i64, i64* %14
  %"$$#0" = icmp eq i64 %11, %15
  ret i1 %"$$#0"
if.else8:
  ret i1 %"tmp$23#0"
if.then9:
  %"tmp$17#0" = and i64 %1, 7
  %"tmp$18#0" = icmp eq i64 %"tmp$17#0", 1
  br i1 %"tmp$18#0", label %if.then10, label %if.else10
if.else9:
  ret i1 %"tmp$11#0"
if.then10:
  %16 = bitcast i64* %"$left#0" to i64*
  %17 = getelementptr i64, i64* %16, i64 0
  %18 = load i64, i64* %17
  %19 = ptrtoint i64* %"$right#0" to i64
  %"tmp$21#0" = icmp ne i64 %19, 0
  br i1 %"tmp$21#0", label %if.then11, label %if.else11
if.else10:
  ret i1 %"tmp$18#0"
if.then11:
  %"tmp$22#0" = and i64 %19, 7
  %"tmp$23#0" = icmp eq i64 %"tmp$22#0", 1
  br i1 %"tmp$23#0", label %if.then12, label %if.else12
if.else11:
  ret i1 %"tmp$21#0"
if.then12:
  %20 = bitcast i64* %"$right#0" to i64*
  %21 = getelementptr i64, i64* %20, i64 0
  %22 = load i64, i64* %21
  %"$$#0" = icmp eq i64 %18, %22
  ret i1 %"$$#0"
if.else12:
  ret i1 %"tmp$23#0"
}

define external ccc i64* @"multictr.simple.one<0>"(i64 %"one_field#0"){
entry:
  %23 = tail call ccc i8* @wybe_malloc(i32 8)
  %24 = bitcast i8* %23 to i64*
  %25 = bitcast i64* %24 to i64*
  %26 = getelementptr i64, i64* %25, i64 0
  store i64 %"one_field#0", i64* %26
  ret i64* %24
}

define external ccc {i64, i1} @"multictr.simple.one<1>"(i64* %"$#0"){
entry:
  %27 = ptrtoint i64* %"$#0" to i64
  %"tmp$1#0" = icmp ne i64 %27, 0
  br i1 %"tmp$1#0", label %if.then, label %if.else
if.then:
  %"tmp$2#0" = and i64 %27, 7
  %"tmp$4#0" = icmp eq i64 %"tmp$2#0", 0
  br i1 %"tmp$4#0", label %if.then1, label %if.else1
if.else:
  %35 = insertvalue {i64, i1} undef, i64 %30, 0
  %36 = insertvalue {i64, i1} %35, i1 0, 1
  ret i1 0
if.then1:
  %28 = bitcast i64* %"$#0" to i64*
  %29 = getelementptr i64, i64* %28, i64 0
  %30 = load i64, i64* %29
  %31 = insertvalue {i64, i1} undef, i64 %30, 0
  %32 = insertvalue {i64, i1} %31, i1 1, 1
  ret i1 1
if.else1:
  %33 = insertvalue {i64, i1} undef, i64 %30, 0
  %34 = insertvalue {i64, i1} %33, i1 0, 1
  ret i1 %"tmp$4#0"
}

define external ccc {i64, i1} @"multictr.simple.one_field<0>"(i64* %"$rec#0"){
entry:
  %37 = ptrtoint i64* %"$rec#0" to i64
  %"tmp$1#0" = icmp ne i64 %37, 0
  br i1 %"tmp$1#0", label %if.then, label %if.else
if.then:
  %"tmp$2#0" = and i64 %37, 7
  %"tmp$4#0" = icmp eq i64 %"tmp$2#0", 0
  br i1 %"tmp$4#0", label %if.then1, label %if.else1
if.else:
  %45 = insertvalue {i64, i1} undef, i64 %40, 0
  %46 = insertvalue {i64, i1} %45, i1 0, 1
  ret i1 0
if.then1:
  %38 = bitcast i64* %"$rec#0" to i64*
  %39 = getelementptr i64, i64* %38, i64 0
  %40 = load i64, i64* %39
  %41 = insertvalue {i64, i1} undef, i64 %40, 0
  %42 = insertvalue {i64, i1} %41, i1 1, 1
  ret i1 1
if.else1:
  %43 = insertvalue {i64, i1} undef, i64 %40, 0
  %44 = insertvalue {i64, i1} %43, i1 0, 1
  ret i1 %"tmp$4#0"
}

define external ccc {i64*, i1} @"multictr.simple.one_field<1>"(i64* %"$rec#0", i64 %"$field#0"){
entry:
  %47 = ptrtoint i64* %"$rec#0" to i64
  %"tmp$1#0" = icmp ne i64 %47, 0
  br i1 %"tmp$1#0", label %if.then, label %if.else
if.then:
  %"tmp$2#0" = and i64 %47, 7
  %"tmp$4#0" = icmp eq i64 %"tmp$2#0", 0
  br i1 %"tmp$4#0", label %if.then1, label %if.else1
if.else:
  %58 = insertvalue {i64*, i1} undef, i64* %"$rec#0", 0
  %59 = insertvalue {i64*, i1} %58, i1 0, 1
  ret i64* %"$rec#0"
if.then1:
  %48 = tail call ccc i8* @wybe_malloc(i32 8)
  %49 = bitcast i8* %48 to i64*
  %50 = bitcast i64* %49 to i8*
  %51 = bitcast i64* %"$rec#0" to i8*
  tail call ccc void @llvm.memcpy.p0i8.p0i8.i32(i8* %50, i8* %51, i32 8, i1 0)
  %52 = bitcast i64* %49 to i64*
  %53 = getelementptr i64, i64* %52, i64 0
  store i64 %"$field#0", i64* %53
  %54 = insertvalue {i64*, i1} undef, i64* %49, 0
  %55 = insertvalue {i64*, i1} %54, i1 1, 1
  ret i1 1
if.else1:
  %56 = insertvalue {i64*, i1} undef, i64* %"$rec#0", 0
  %57 = insertvalue {i64*, i1} %56, i1 0, 1
  ret i1 %"tmp$4#0"
}

define external ccc i64* @"multictr.simple.two<0>"(i64 %"two_field#0"){
entry:
  %60 = tail call ccc i8* @wybe_malloc(i32 8)
  %61 = bitcast i8* %60 to i64*
  %62 = bitcast i64* %61 to i64*
  %63 = getelementptr i64, i64* %62, i64 0
  store i64 %"two_field#0", i64* %63
  %64 = ptrtoint i64* %61 to i64
  %"$recinttagged#0" = or i64 %64, 1
  %65 = inttoptr i64 %"$recinttagged#0" to i64*
  ret i64* %65
}

define external ccc {i64, i1} @"multictr.simple.two<1>"(i64* %"$#0"){
entry:
  %66 = ptrtoint i64* %"$#0" to i64
  %"tmp$1#0" = icmp ne i64 %66, 0
  br i1 %"tmp$1#0", label %if.then, label %if.else
if.then:
  %"tmp$2#0" = and i64 %66, 7
  %"tmp$4#0" = icmp eq i64 %"tmp$2#0", 1
  br i1 %"tmp$4#0", label %if.then1, label %if.else1
if.else:
  %74 = insertvalue {i64, i1} undef, i64 %69, 0
  %75 = insertvalue {i64, i1} %74, i1 0, 1
  ret i1 0
if.then1:
  %67 = bitcast i64* %"$#0" to i64*
  %68 = getelementptr i64, i64* %67, i64 0
  %69 = load i64, i64* %68
  %70 = insertvalue {i64, i1} undef, i64 %69, 0
  %71 = insertvalue {i64, i1} %70, i1 1, 1
  ret i1 1
if.else1:
  %72 = insertvalue {i64, i1} undef, i64 %69, 0
  %73 = insertvalue {i64, i1} %72, i1 0, 1
  ret i1 %"tmp$4#0"
}

define external ccc {i64, i1} @"multictr.simple.two_field<0>"(i64* %"$rec#0"){
entry:
  %76 = ptrtoint i64* %"$rec#0" to i64
  %"tmp$1#0" = icmp ne i64 %76, 0
  br i1 %"tmp$1#0", label %if.then, label %if.else
if.then:
  %"tmp$2#0" = and i64 %76, 7
  %"tmp$4#0" = icmp eq i64 %"tmp$2#0", 1
  br i1 %"tmp$4#0", label %if.then1, label %if.else1
if.else:
  %84 = insertvalue {i64, i1} undef, i64 %79, 0
  %85 = insertvalue {i64, i1} %84, i1 0, 1
  ret i1 0
if.then1:
  %77 = bitcast i64* %"$rec#0" to i64*
  %78 = getelementptr i64, i64* %77, i64 0
  %79 = load i64, i64* %78
  %80 = insertvalue {i64, i1} undef, i64 %79, 0
  %81 = insertvalue {i64, i1} %80, i1 1, 1
  ret i1 1
if.else1:
  %82 = insertvalue {i64, i1} undef, i64 %79, 0
  %83 = insertvalue {i64, i1} %82, i1 0, 1
  ret i1 %"tmp$4#0"
}

define external ccc {i64*, i1} @"multictr.simple.two_field<1>"(i64* %"$rec#0", i64 %"$field#0"){
entry:
  %86 = ptrtoint i64* %"$rec#0" to i64
  %"tmp$1#0" = icmp ne i64 %86, 0
  br i1 %"tmp$1#0", label %if.then, label %if.else
if.then:
  %"tmp$2#0" = and i64 %86, 7
  %"tmp$4#0" = icmp eq i64 %"tmp$2#0", 1
  br i1 %"tmp$4#0", label %if.then1, label %if.else1
if.else:
  %97 = insertvalue {i64*, i1} undef, i64* %"$rec#0", 0
  %98 = insertvalue {i64*, i1} %97, i1 0, 1
  ret i64* %"$rec#0"
if.then1:
  %87 = tail call ccc i8* @wybe_malloc(i32 8)
  %88 = bitcast i8* %87 to i64*
  %89 = bitcast i64* %88 to i8*
  %90 = bitcast i64* %"$rec#0" to i8*
  tail call ccc void @llvm.memcpy.p0i8.p0i8.i32(i8* %89, i8* %90, i32 8, i1 0)
  %91 = bitcast i64* %88 to i64*
  %92 = getelementptr i64, i64* %91, i64 0
  store i64 %"$field#0", i64* %92
  %93 = insertvalue {i64*, i1} undef, i64* %88, 0
  %94 = insertvalue {i64*, i1} %93, i1 1, 1
  ret i1 1
if.else1:
  %95 = insertvalue {i64*, i1} undef, i64* %"$rec#0", 0
  %96 = insertvalue {i64*, i1} %95, i1 0, 1
  ret i1 %"tmp$4#0"
}

define external ccc i64* @"multictr.simple.zero<0>"(){
entry:
  ret i64 0
}
