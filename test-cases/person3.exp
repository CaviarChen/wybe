======================================================================
AFTER EVERYTHING:
 Module person3
  public submods  : 
  public types    : person: (person3.person,"pointer")
  public resources: 
  public procs    : person3.<0>
                    person3.person.=<0>
                    person3.person.firstname<0>
                    person3.person.firstname<1>
                    person3.person.lastname<0>
                    person3.person.lastname<1>
                    person3.person.person<0>
                    person3.person.person<1>
  imports         : public use person3.person
                    use wybe
  types           : person/0 (pointer)  @person3:1:8
  resources       : 
  submodules      : person3.person
  procs           : 

*main* > public (0 calls)
0: (argc#0:wybe.int, [?argc#0:wybe.int], argv#0:wybe.int, [?argv#0:wybe.int], exit_code#0:wybe.int, [?exit_code#0:wybe.int], io#0:phantom, ?io#2:phantom): AliasPairs: []
    foreign lpvm alloc(16:wybe.int, ?tmp$5#0:person3.person)
    foreign lpvm mutate(~tmp$5#0:person3.person, ?tmp$6#0:person3.person, 16:wybe.int, 0:wybe.int, 1:wybe.int, "John":wybe.string)
    foreign lpvm mutate(~tmp$6#0:person3.person, ?tmp$7#0:person3.person, 16:wybe.int, 8:wybe.int, 1:wybe.int, "Smith":wybe.string)
    foreign lpvm mutate(tmp$7#0:person3.person, ?%personB#1:person3.person, 16:wybe.int, 0:wybe.int, 0:wybe.int, "Jane":wybe.string)
    foreign lpvm mutate(~%personB#1:person3.person, ?%personB#2:person3.person, 16:wybe.int, 8:wybe.int, 1:wybe.int, "Wang":wybe.string)
    foreign lpvm access(~tmp$7#0:person3.person, 8:wybe.int, ?tmp$1#0:wybe.string)
    foreign c print_string(~tmp$1#0:wybe.string, ~#io#0:phantom, ?#io#1:phantom) @wybe:nn:nn
    foreign lpvm access(~personB#2:person3.person, 8:wybe.int, ?tmp$2#0:wybe.string)
    foreign c print_string(~tmp$2#0:wybe.string, ~#io#1:phantom, ?#io#2:phantom) @wybe:nn:nn

  LLVM code       :

; ModuleID = 'person3'


declare external ccc void @print_string(i8*)

@person3.16 = constant [5 x i8] c"Wang\00"

@person3.9 = constant [5 x i8] c"Jane\00"

@person3.6 = constant [6 x i8] c"Smith\00"

@person3.3 = constant [5 x i8] c"John\00"

declare external ccc i8* @wybe_malloc(i32)

declare external ccc void @llvm.memcpy.p0i8.p0i8.i32(i8*, i8*, i32, i1)

define external ccc void @"person3.<0>"(i64 %"argc#0", i64 %"argv#0", i64 %"exit_code#0"){
entry:
  %1 = tail call ccc i8* @wybe_malloc(i32 16)
  %2 = bitcast i8* %1 to i64*
  %4 = bitcast i64* %2 to i8**
  %5 = getelementptr i8*, i8** %4, i64 0
  store i8* getelementptr inbounds ([5 x i8], [5 x i8]* @person3.3, i32 0, i32 0), i8** %5
  %7 = bitcast i64* %2 to i8**
  %8 = getelementptr i8*, i8** %7, i64 8
  store i8* getelementptr inbounds ([6 x i8], [6 x i8]* @person3.6, i32 0, i32 0), i8** %8
  %10 = tail call ccc i8* @wybe_malloc(i32 16)
  %11 = bitcast i8* %10 to i64*
  %12 = bitcast i64* %11 to i8*
  %13 = bitcast i64* %2 to i8*
  tail call ccc void @llvm.memcpy.p0i8.p0i8.i32(i8* %12, i8* %13, i32 16, i1 0)
  %14 = bitcast i64* %11 to i8**
  %15 = getelementptr i8*, i8** %14, i64 0
  store i8* getelementptr inbounds ([5 x i8], [5 x i8]* @person3.9, i32 0, i32 0), i8** %15
  %17 = bitcast i64* %11 to i8**
  %18 = getelementptr i8*, i8** %17, i64 8
  store i8* getelementptr inbounds ([5 x i8], [5 x i8]* @person3.16, i32 0, i32 0), i8** %18
  %19 = bitcast i64* %2 to i8**
  %20 = getelementptr i8*, i8** %19, i64 8
  %21 = load i8*, i8** %20
  %22 = inttoptr i8* %21 to i8*
  tail call ccc void @print_string(i8* %22)
  %23 = bitcast i64* %11 to i8**
  %24 = getelementptr i8*, i8** %23, i64 8
  %25 = load i8*, i8** %24
  %26 = inttoptr i8* %25 to i8*
  tail call ccc void @print_string(i8* %26)
  ret void
}
--------------------------------------------------
 Module person3.person([])
  public submods  : 
  public types    : 
  public resources: 
  public procs    : person3.person.=<0>
                    person3.person.firstname<0>
                    person3.person.firstname<1>
                    person3.person.lastname<0>
                    person3.person.lastname<1>
                    person3.person.person<0>
                    person3.person.person<1>
  imports         : use person3
                    use wybe
  types           : 
  resources       : 
  procs           : 

= > public inline test (3 calls)
0: =($left#0:person3.person, $right#0:person3.person, ?$$#0:wybe.bool): AliasPairs: []
    foreign lpvm access($left#0:person3.person, 0:wybe.int, ?$left$firstname#0:wybe.string)
    foreign lpvm access(~$left#0:person3.person, 8:wybe.int, ?$left$lastname#0:wybe.string)
    foreign lpvm access($right#0:person3.person, 0:wybe.int, ?$right$firstname#0:wybe.string)
    foreign lpvm access(~$right#0:person3.person, 8:wybe.int, ?$right$lastname#0:wybe.string)
    foreign c strcmp(~$left$firstname#0:wybe.string, ~$right$firstname#0:wybe.string, ?tmp$8#0:wybe.int) @wybe:nn:nn
    wybe.int.=<0>(~tmp$8#0:wybe.int, 0:wybe.int, ?tmp$2#0:wybe.bool) @wybe:nn:nn
    case ~tmp$2#0:wybe.bool of
    0:
        foreign llvm move(0:wybe.bool, ?$$#0:wybe.bool)

    1:
        foreign c strcmp(~$left$lastname#0:wybe.string, ~$right$lastname#0:wybe.string, ?tmp$11#0:wybe.int) @wybe:nn:nn
        wybe.int.=<0>(~tmp$11#0:wybe.int, 0:wybe.int, ?$$#0:wybe.bool) @wybe:nn:nn



firstname > public inline (0 calls)
0: firstname($rec#0:person3.person, ?$#0:wybe.string): AliasPairs: []
    foreign lpvm access(~$rec#0:person3.person, 0:wybe.int, ?$#0:wybe.string)
firstname > public inline (0 calls)
1: firstname($rec#0:person3.person, ?$rec#1:person3.person, $field#0:wybe.string): AliasPairs: []
    foreign lpvm mutate(~%$rec#0:person3.person, ?%$rec#1:person3.person, 16:wybe.int, 0:wybe.int, 0:wybe.int, ~$field#0:wybe.string)


lastname > public inline (0 calls)
0: lastname($rec#0:person3.person, ?$#0:wybe.string): AliasPairs: []
    foreign lpvm access(~$rec#0:person3.person, 8:wybe.int, ?$#0:wybe.string)
lastname > public inline (0 calls)
1: lastname($rec#0:person3.person, ?$rec#1:person3.person, $field#0:wybe.string): AliasPairs: []
    foreign lpvm mutate(~%$rec#0:person3.person, ?%$rec#1:person3.person, 16:wybe.int, 8:wybe.int, 0:wybe.int, ~$field#0:wybe.string)


person > public inline (0 calls)
0: person(firstname#0:wybe.string, lastname#0:wybe.string, ?$#0:person3.person): AliasPairs: []
    foreign lpvm alloc(16:wybe.int, ?$rec#0:person3.person)
    foreign lpvm mutate(~%$rec#0:person3.person, ?%$rec#1:person3.person, 16:wybe.int, 0:wybe.int, 1:wybe.int, ~firstname#0:wybe.string)
    foreign lpvm mutate(~%$rec#1:person3.person, ?%$#0:person3.person, 16:wybe.int, 8:wybe.int, 1:wybe.int, ~lastname#0:wybe.string)
person > public inline (4 calls)
1: person(?firstname#0:wybe.string, ?lastname#0:wybe.string, $#0:person3.person): AliasPairs: []
    foreign lpvm access($#0:person3.person, 0:wybe.int, ?firstname#0:wybe.string)
    foreign lpvm access(~$#0:person3.person, 8:wybe.int, ?lastname#0:wybe.string)

  LLVM code       :

; ModuleID = 'person3.person'


declare external ccc i1 @"wybe.int.=<0>"(i64, i64)

declare external ccc i64 @strcmp(i8*, i8*)

declare external ccc i8* @wybe_malloc(i32)

declare external ccc void @llvm.memcpy.p0i8.p0i8.i32(i8*, i8*, i32, i1)

define external ccc i1 @"person3.person.=<0>"(i64* %"$left#0", i64* %"$right#0"){
entry:
  %1 = bitcast i64* %"$left#0" to i8**
  %2 = getelementptr i8*, i8** %1, i64 0
  %3 = load i8*, i8** %2
  %4 = inttoptr i8* %3 to i8*
  %5 = bitcast i64* %"$left#0" to i8**
  %6 = getelementptr i8*, i8** %5, i64 8
  %7 = load i8*, i8** %6
  %8 = inttoptr i8* %7 to i8*
  %9 = bitcast i64* %"$right#0" to i8**
  %10 = getelementptr i8*, i8** %9, i64 0
  %11 = load i8*, i8** %10
  %12 = inttoptr i8* %11 to i8*
  %13 = bitcast i64* %"$right#0" to i8**
  %14 = getelementptr i8*, i8** %13, i64 8
  %15 = load i8*, i8** %14
  %16 = inttoptr i8* %15 to i8*
  %"tmp$8#0" = tail call ccc i64 @strcmp(i8* %4, i8* %12)
  %"tmp$2#0" = tail call ccc i1 @"wybe.int.=<0>"(i64 %"tmp$8#0", i64 0)
  br i1 %"tmp$2#0", label %if.then, label %if.else
if.then:
  %"tmp$11#0" = tail call ccc i64 @strcmp(i8* %8, i8* %16)
  %"$$#0" = tail call ccc i1 @"wybe.int.=<0>"(i64 %"tmp$11#0", i64 0)
  ret i1 %"$$#0"
if.else:
  ret i1 0
}

define external ccc i8* @"person3.person.firstname<0>"(i64* %"$rec#0"){
entry:
  %17 = bitcast i64* %"$rec#0" to i8**
  %18 = getelementptr i8*, i8** %17, i64 0
  %19 = load i8*, i8** %18
  %20 = inttoptr i8* %19 to i8*
  ret i8* %20
}

define external ccc i64* @"person3.person.firstname<1>"(i64* %"$rec#0", i8* %"$field#0"){
entry:
  %21 = tail call ccc i8* @wybe_malloc(i32 16)
  %22 = bitcast i8* %21 to i64*
  %23 = bitcast i64* %22 to i8*
  %24 = bitcast i64* %"$rec#0" to i8*
  tail call ccc void @llvm.memcpy.p0i8.p0i8.i32(i8* %23, i8* %24, i32 16, i1 0)
  %25 = bitcast i64* %22 to i8**
  %26 = getelementptr i8*, i8** %25, i64 0
  store i8* %"$field#0", i8** %26
  ret i64* %22
}

define external ccc i8* @"person3.person.lastname<0>"(i64* %"$rec#0"){
entry:
  %27 = bitcast i64* %"$rec#0" to i8**
  %28 = getelementptr i8*, i8** %27, i64 8
  %29 = load i8*, i8** %28
  %30 = inttoptr i8* %29 to i8*
  ret i8* %30
}

define external ccc i64* @"person3.person.lastname<1>"(i64* %"$rec#0", i8* %"$field#0"){
entry:
  %31 = tail call ccc i8* @wybe_malloc(i32 16)
  %32 = bitcast i8* %31 to i64*
  %33 = bitcast i64* %32 to i8*
  %34 = bitcast i64* %"$rec#0" to i8*
  tail call ccc void @llvm.memcpy.p0i8.p0i8.i32(i8* %33, i8* %34, i32 16, i1 0)
  %35 = bitcast i64* %32 to i8**
  %36 = getelementptr i8*, i8** %35, i64 8
  store i8* %"$field#0", i8** %36
  ret i64* %32
}

define external ccc i64* @"person3.person.person<0>"(i8* %"firstname#0", i8* %"lastname#0"){
entry:
  %37 = tail call ccc i8* @wybe_malloc(i32 16)
  %38 = bitcast i8* %37 to i64*
  %39 = bitcast i64* %38 to i8**
  %40 = getelementptr i8*, i8** %39, i64 0
  store i8* %"firstname#0", i8** %40
  %41 = bitcast i64* %38 to i8**
  %42 = getelementptr i8*, i8** %41, i64 8
  store i8* %"lastname#0", i8** %42
  ret i64* %38
}

define external ccc {i8*, i8*} @"person3.person.person<1>"(i64* %"$#0"){
entry:
  %43 = bitcast i64* %"$#0" to i8**
  %44 = getelementptr i8*, i8** %43, i64 0
  %45 = load i8*, i8** %44
  %46 = inttoptr i8* %45 to i8*
  %47 = bitcast i64* %"$#0" to i8**
  %48 = getelementptr i8*, i8** %47, i64 8
  %49 = load i8*, i8** %48
  %50 = inttoptr i8* %49 to i8*
  %51 = insertvalue {i8*, i8*} undef, i8* %46, 0
  %52 = insertvalue {i8*, i8*} %51, i8* %50, 1
  ret {i8*, i8*} %52
}
