======================================================================
AFTER EVERYTHING:
 Module alias_fork3
  public submods  : 
  public types    : 
  public resources: 
  public procs    : alias_fork3.<0>
                    alias_fork3.simpleSlice<0>
  imports         : use mytree
                    use wybe
  types           : 
  resources       : 
  procs           : 

*main* > public (0 calls)
0: (argc#0:wybe.int, [?argc#0:wybe.int], argv#0:wybe.int, [?argv#0:wybe.int], exit_code#0:wybe.int, [?exit_code#0:wybe.int], io#0:phantom, ?io#3:phantom): AliasPairs: []
    foreign lpvm alloc(24:wybe.int, ?tmp$9#0:mytree.tree)
    foreign lpvm mutate(~tmp$9#0:mytree.tree, ?tmp$10#0:mytree.tree, 24:wybe.int, 0:wybe.int, 1:wybe.int, 0:mytree.tree)
    foreign lpvm mutate(~tmp$10#0:mytree.tree, ?tmp$11#0:mytree.tree, 24:wybe.int, 8:wybe.int, 1:wybe.int, 100:wybe.int)
    foreign lpvm mutate(~tmp$11#0:mytree.tree, ?tmp$1#0:mytree.tree, 24:wybe.int, 16:wybe.int, 1:wybe.int, 0:mytree.tree)
    foreign lpvm alloc(24:wybe.int, ?tmp$15#0:mytree.tree)
    foreign lpvm mutate(~tmp$15#0:mytree.tree, ?tmp$16#0:mytree.tree, 24:wybe.int, 0:wybe.int, 1:wybe.int, ~tmp$1#0:mytree.tree)
    foreign lpvm mutate(~tmp$16#0:mytree.tree, ?tmp$17#0:mytree.tree, 24:wybe.int, 8:wybe.int, 1:wybe.int, 200:wybe.int)
    foreign lpvm mutate(~tmp$17#0:mytree.tree, ?tmp$0#0:mytree.tree, 24:wybe.int, 16:wybe.int, 1:wybe.int, 0:mytree.tree)
    alias_fork3.simpleSlice<0>(~tmp$0#0:mytree.tree, ?tmp$5#0:mytree.tree) @alias_fork3:14:6
    foreign c print_string("expect t - 100:":wybe.string, ~#io#0:phantom, ?tmp$20#0:phantom) @wybe:nn:nn
    foreign c putchar('\n':wybe.char, ~tmp$20#0:phantom, ?#io#1:phantom) @wybe:nn:nn
    mytree.printTree<0>(~tmp$5#0:mytree.tree, ~#io#1:phantom, ?#io#2:phantom) @alias_fork3:16:2
    foreign c print_string("":wybe.string, ~#io#2:phantom, ?tmp$23#0:phantom) @wybe:nn:nn
    foreign c putchar('\n':wybe.char, ~tmp$23#0:phantom, ?#io#3:phantom) @wybe:nn:nn


simpleSlice > public (1 calls)
0: simpleSlice(tr#0:mytree.tree, ?$#0:mytree.tree): AliasPairs: [($#0,tr#0)]
    foreign lpvm cast(tr#0:mytree.tree, ?tmp$7#0:wybe.int)
    foreign llvm icmp ne(~tmp$7#0:wybe.int, 0:wybe.int, ?tmp$8#0:wybe.bool)
    case ~tmp$8#0:wybe.bool of
    0:
        foreign lpvm alloc(24:wybe.int, ?tmp$13#0:mytree.tree)
        foreign lpvm mutate(~tmp$13#0:mytree.tree, ?tmp$14#0:mytree.tree, 24:wybe.int, 0:wybe.int, 1:wybe.int, 0:mytree.tree)
        foreign lpvm mutate(~tmp$14#0:mytree.tree, ?tmp$15#0:mytree.tree, 24:wybe.int, 8:wybe.int, 1:wybe.int, -1:wybe.int)
        foreign lpvm mutate(~tmp$15#0:mytree.tree, ?$#0:mytree.tree, 24:wybe.int, 16:wybe.int, 1:wybe.int, 0:mytree.tree)

    1:
        foreign lpvm access(~tr#0:mytree.tree, 0:wybe.int, ?l#0:mytree.tree)
        foreign llvm move(~l#0:mytree.tree, ?$#0:mytree.tree) @alias_fork3:9:8


  LLVM code       :

; ModuleID = 'alias_fork3'


declare external ccc void @putchar(i8)

declare external ccc void @print_string(i8*)

declare external ccc void @"mytree.printTree<0>"(i64*)

@alias_fork3.18 = constant [1 x i8] c"\00"

@alias_fork3.17 = constant [16 x i8] c"expect t - 100:\00"

declare external ccc i8* @wybe_malloc(i32)

declare external ccc void @llvm.memcpy.p0i8.p0i8.i32(i8*, i8*, i32, i1)

define external ccc void @"alias_fork3.<0>"(i64 %"argc#0", i64 %"argv#0", i64 %"exit_code#0"){
entry:
  %1 = tail call ccc i8* @wybe_malloc(i32 24)
  %2 = bitcast i8* %1 to i64*
  %3 = bitcast i64* %2 to i64**
  %4 = getelementptr i64*, i64** %3, i64 0
  store i64 0, i64** %4
  %5 = bitcast i64* %2 to i64*
  %6 = getelementptr i64, i64* %5, i64 1
  store i64 100, i64* %6
  %7 = bitcast i64* %2 to i64**
  %8 = getelementptr i64*, i64** %7, i64 2
  store i64 0, i64** %8
  %9 = tail call ccc i8* @wybe_malloc(i32 24)
  %10 = bitcast i8* %9 to i64*
  %11 = bitcast i64* %10 to i64**
  %12 = getelementptr i64*, i64** %11, i64 0
  store i64* %2, i64** %12
  %13 = bitcast i64* %10 to i64*
  %14 = getelementptr i64, i64* %13, i64 1
  store i64 200, i64* %14
  %15 = bitcast i64* %10 to i64**
  %16 = getelementptr i64*, i64** %15, i64 2
  store i64 0, i64** %16
  %"tmp$5#0" = tail call ccc i64* @"alias_fork3.simpleSlice<0>"(i64* %10)
  tail call ccc void @print_string(i8* getelementptr inbounds ([16 x i8], [16 x i8]* @alias_fork3.17, i32 0, i32 0))
  tail call ccc void @putchar(i8 10)
  tail call ccc void @"mytree.printTree<0>"(i64* %"tmp$5#0")
  tail call ccc void @print_string(i8* getelementptr inbounds ([1 x i8], [1 x i8]* @alias_fork3.18, i32 0, i32 0))
  tail call ccc void @putchar(i8 10)
  ret void
}

define external ccc i64* @"alias_fork3.simpleSlice<0>"(i64* %"tr#0"){
entry:
  %19 = ptrtoint i64* %"tr#0" to i64
  %"tmp$8#0" = icmp ne i64 %19, 0
  br i1 %"tmp$8#0", label %if.then, label %if.else
if.then:
  %20 = bitcast i64* %"tr#0" to i64**
  %21 = getelementptr i64*, i64** %20, i64 0
  %22 = load i64*, i64** %21
  %23 = inttoptr i64* %22 to i64*
  ret i64* %23
if.else:
  %24 = tail call ccc i8* @wybe_malloc(i32 24)
  %25 = bitcast i8* %24 to i64*
  %26 = bitcast i64* %25 to i64**
  %27 = getelementptr i64*, i64** %26, i64 0
  store i64 0, i64** %27
  %28 = bitcast i64* %25 to i64*
  %29 = getelementptr i64, i64* %28, i64 1
  store i64 -1, i64* %29
  %30 = bitcast i64* %25 to i64**
  %31 = getelementptr i64*, i64** %30, i64 2
  store i64 0, i64** %31
  ret i64* %25
}
--------------------------------------------------
 Module mytree
  public submods  : 
  public types    : tree: (mytree.tree,"pointer")
  public resources: 
  public procs    : mytree.printTree<0>
                    mytree.tree.=<0>
                    mytree.tree.empty<0>
                    mytree.tree.key<0>
                    mytree.tree.key<1>
                    mytree.tree.left<0>
                    mytree.tree.left<1>
                    mytree.tree.node<0>
                    mytree.tree.node<1>
                    mytree.tree.right<0>
                    mytree.tree.right<1>
  imports         : public use mytree.tree
                    use wybe
  types           : tree/0 (pointer)  @mytree:1:8
  resources       : 
  submodules      : mytree.tree
  procs           : 

printTree > public (2 calls)
0: printTree(t#0:mytree.tree, io#0:phantom, ?io#5:phantom): AliasPairs: []
    foreign lpvm cast(t#0:mytree.tree, ?tmp$2#0:wybe.int)
    foreign llvm icmp ne(~tmp$2#0:wybe.int, 0:wybe.int, ?tmp$3#0:wybe.bool)
    case ~tmp$3#0:wybe.bool of
    0:
        foreign llvm move(~io#0:phantom, ?io#5:phantom)

    1:
        foreign lpvm access(t#0:mytree.tree, 0:wybe.int, ?l#0:mytree.tree)
        foreign lpvm access(t#0:mytree.tree, 8:wybe.int, ?k#0:wybe.int)
        foreign lpvm access(~t#0:mytree.tree, 16:wybe.int, ?r#0:mytree.tree)
        mytree.printTree<0>(~l#0:mytree.tree, ~#io#0:phantom, ?#io#1:phantom) @mytree:5:6
        foreign c print_string(" ":wybe.string, ~#io#1:phantom, ?#io#2:phantom) @wybe:nn:nn
        foreign c print_int(~k#0:wybe.int, ~#io#2:phantom, ?#io#3:phantom) @wybe:nn:nn
        foreign c print_string(" ":wybe.string, ~#io#3:phantom, ?#io#4:phantom) @wybe:nn:nn
        mytree.printTree<0>(~r#0:mytree.tree, ~#io#4:phantom, ?#io#5:phantom) @mytree:9:6


  LLVM code       :

; ModuleID = 'mytree'


declare external ccc void @print_string(i8*)

declare external ccc void @print_int(i64)

@mytree.14 = constant [2 x i8] c" \00"

@mytree.13 = constant [2 x i8] c" \00"

declare external ccc i8* @wybe_malloc(i32)

declare external ccc void @llvm.memcpy.p0i8.p0i8.i32(i8*, i8*, i32, i1)

define external ccc void @"mytree.printTree<0>"(i64* %"t#0"){
entry:
  %1 = ptrtoint i64* %"t#0" to i64
  %"tmp$3#0" = icmp ne i64 %1, 0
  br i1 %"tmp$3#0", label %if.then, label %if.else
if.then:
  %2 = bitcast i64* %"t#0" to i64**
  %3 = getelementptr i64*, i64** %2, i64 0
  %4 = load i64*, i64** %3
  %5 = inttoptr i64* %4 to i64*
  %6 = bitcast i64* %"t#0" to i64*
  %7 = getelementptr i64, i64* %6, i64 1
  %8 = load i64, i64* %7
  %9 = bitcast i64* %"t#0" to i64**
  %10 = getelementptr i64*, i64** %9, i64 2
  %11 = load i64*, i64** %10
  %12 = inttoptr i64* %11 to i64*
  tail call ccc void @"mytree.printTree<0>"(i64* %5)
  tail call ccc void @print_string(i8* getelementptr inbounds ([2 x i8], [2 x i8]* @mytree.13, i32 0, i32 0))
  tail call ccc void @print_int(i64 %8)
  tail call ccc void @print_string(i8* getelementptr inbounds ([2 x i8], [2 x i8]* @mytree.14, i32 0, i32 0))
  tail call ccc void @"mytree.printTree<0>"(i64* %12)
  ret void
if.else:
  ret void
}
--------------------------------------------------
 Module mytree.tree([])
  public submods  : 
  public types    : 
  public resources: 
  public procs    : mytree.tree.=<0>
                    mytree.tree.empty<0>
                    mytree.tree.key<0>
                    mytree.tree.key<1>
                    mytree.tree.left<0>
                    mytree.tree.left<1>
                    mytree.tree.node<0>
                    mytree.tree.node<1>
                    mytree.tree.right<0>
                    mytree.tree.right<1>
  imports         : use mytree
                    use wybe
  types           : 
  resources       : 
  procs           : 

= > public test (6 calls)
0: =($left#0:mytree.tree, $right#0:mytree.tree, ?$$#0:wybe.bool): AliasPairs: []
    foreign lpvm cast($left#0:mytree.tree, ?tmp$0#0:wybe.int)
    foreign llvm icmp eq(tmp$0#0:wybe.int, 0:wybe.int, ?tmp$1#0:wybe.bool)
    case ~tmp$1#0:wybe.bool of
    0:
        foreign llvm icmp ne(~tmp$0#0:wybe.int, 0:wybe.int, ?tmp$10#0:wybe.bool)
        case ~tmp$10#0:wybe.bool of
        0:
            foreign llvm move(0:wybe.bool, ?$$#0:wybe.bool)

        1:
            foreign lpvm access($left#0:mytree.tree, 0:wybe.int, ?$left$left#0:mytree.tree)
            foreign lpvm access($left#0:mytree.tree, 8:wybe.int, ?$left$key#0:wybe.int)
            foreign lpvm access(~$left#0:mytree.tree, 16:wybe.int, ?$left$right#0:mytree.tree)
            foreign lpvm cast($right#0:mytree.tree, ?tmp$12#0:wybe.int)
            foreign llvm icmp ne(~tmp$12#0:wybe.int, 0:wybe.int, ?tmp$13#0:wybe.bool)
            case ~tmp$13#0:wybe.bool of
            0:
                foreign llvm move(0:wybe.bool, ?$$#0:wybe.bool)

            1:
                foreign lpvm access($right#0:mytree.tree, 0:wybe.int, ?$right$left#0:mytree.tree)
                foreign lpvm access($right#0:mytree.tree, 8:wybe.int, ?$right$key#0:wybe.int)
                foreign lpvm access(~$right#0:mytree.tree, 16:wybe.int, ?$right$right#0:mytree.tree)
                mytree.tree.=<0>(~$left$left#0:mytree.tree, ~$right$left#0:mytree.tree, ?tmp$5#0:wybe.bool)
                case ~tmp$5#0:wybe.bool of
                0:
                    foreign llvm move(0:wybe.bool, ?$$#0:wybe.bool)

                1:
                    foreign llvm icmp eq(~$left$key#0:wybe.int, ~$right$key#0:wybe.int, ?tmp$6#0:wybe.bool) @wybe:nn:nn
                    case ~tmp$6#0:wybe.bool of
                    0:
                        foreign llvm move(0:wybe.bool, ?$$#0:wybe.bool)

                    1:
                        mytree.tree.=<0>(~$left$right#0:mytree.tree, ~$right$right#0:mytree.tree, ?$$#0:wybe.bool)





    1:
        foreign llvm icmp eq(~$left#0:wybe.int, ~$right#0:wybe.int, ?$$#0:wybe.bool)



empty > public inline (0 calls)
0: empty(?$#0:mytree.tree): AliasPairs: []
    foreign llvm move(0:mytree.tree, ?$#0:mytree.tree)


key > public inline test (0 calls)
0: key($rec#0:mytree.tree, ?$#0:wybe.int, ?$$#0:wybe.bool): AliasPairs: []
    foreign lpvm cast($rec#0:mytree.tree, ?tmp$0#0:wybe.int)
    foreign llvm icmp ne(~tmp$0#0:wybe.int, 0:wybe.int, ?tmp$1#0:wybe.bool)
    case ~tmp$1#0:wybe.bool of
    0:
        foreign llvm move(0:wybe.bool, ?$$#0:wybe.bool)

    1:
        foreign lpvm access(~$rec#0:mytree.tree, 8:wybe.int, ?$#0:wybe.int)
        foreign llvm move(1:wybe.bool, ?$$#0:wybe.bool)

key > public inline test (0 calls)
1: key($rec#0:mytree.tree, ?$rec#1:mytree.tree, $field#0:wybe.int, ?$$#0:wybe.bool): AliasPairs: []
    foreign lpvm cast($rec#0:mytree.tree, ?tmp$0#0:wybe.int)
    foreign llvm icmp ne(~tmp$0#0:wybe.int, 0:wybe.int, ?tmp$1#0:wybe.bool)
    case ~tmp$1#0:wybe.bool of
    0:
        foreign llvm move(0:wybe.bool, ?$$#0:wybe.bool)
        foreign llvm move(~$rec#0:mytree.tree, ?$rec#1:mytree.tree)

    1:
        foreign lpvm mutate(~%$rec#0:mytree.tree, ?%$rec#1:mytree.tree, 24:wybe.int, 8:wybe.int, 0:wybe.int, ~$field#0:wybe.int)
        foreign llvm move(1:wybe.bool, ?$$#0:wybe.bool)



left > public inline test (0 calls)
0: left($rec#0:mytree.tree, ?$#0:mytree.tree, ?$$#0:wybe.bool): AliasPairs: []
    foreign lpvm cast($rec#0:mytree.tree, ?tmp$0#0:wybe.int)
    foreign llvm icmp ne(~tmp$0#0:wybe.int, 0:wybe.int, ?tmp$1#0:wybe.bool)
    case ~tmp$1#0:wybe.bool of
    0:
        foreign llvm move(0:wybe.bool, ?$$#0:wybe.bool)

    1:
        foreign lpvm access(~$rec#0:mytree.tree, 0:wybe.int, ?$#0:mytree.tree)
        foreign llvm move(1:wybe.bool, ?$$#0:wybe.bool)

left > public inline test (0 calls)
1: left($rec#0:mytree.tree, ?$rec#1:mytree.tree, $field#0:mytree.tree, ?$$#0:wybe.bool): AliasPairs: []
    foreign lpvm cast($rec#0:mytree.tree, ?tmp$0#0:wybe.int)
    foreign llvm icmp ne(~tmp$0#0:wybe.int, 0:wybe.int, ?tmp$1#0:wybe.bool)
    case ~tmp$1#0:wybe.bool of
    0:
        foreign llvm move(0:wybe.bool, ?$$#0:wybe.bool)
        foreign llvm move(~$rec#0:mytree.tree, ?$rec#1:mytree.tree)

    1:
        foreign lpvm mutate(~%$rec#0:mytree.tree, ?%$rec#1:mytree.tree, 24:wybe.int, 0:wybe.int, 0:wybe.int, ~$field#0:mytree.tree)
        foreign llvm move(1:wybe.bool, ?$$#0:wybe.bool)



node > public inline (0 calls)
0: node(left#0:mytree.tree, key#0:wybe.int, right#0:mytree.tree, ?$#0:mytree.tree): AliasPairs: []
    foreign lpvm alloc(24:wybe.int, ?$rec#0:mytree.tree)
    foreign lpvm mutate(~%$rec#0:mytree.tree, ?%$rec#1:mytree.tree, 24:wybe.int, 0:wybe.int, 1:wybe.int, ~left#0:mytree.tree)
    foreign lpvm mutate(~%$rec#1:mytree.tree, ?%$rec#2:mytree.tree, 24:wybe.int, 8:wybe.int, 1:wybe.int, ~key#0:wybe.int)
    foreign lpvm mutate(~%$rec#2:mytree.tree, ?%$#0:mytree.tree, 24:wybe.int, 16:wybe.int, 1:wybe.int, ~right#0:mytree.tree)
node > public inline test (9 calls)
1: node(?left#0:mytree.tree, ?key#0:wybe.int, ?right#0:mytree.tree, $#0:mytree.tree, ?$$#0:wybe.bool): AliasPairs: []
    foreign lpvm cast($#0:mytree.tree, ?tmp$0#0:wybe.int)
    foreign llvm icmp ne(~tmp$0#0:wybe.int, 0:wybe.int, ?tmp$1#0:wybe.bool)
    case ~tmp$1#0:wybe.bool of
    0:
        foreign llvm move(0:wybe.bool, ?$$#0:wybe.bool)

    1:
        foreign lpvm access($#0:mytree.tree, 0:wybe.int, ?left#0:mytree.tree)
        foreign lpvm access($#0:mytree.tree, 8:wybe.int, ?key#0:wybe.int)
        foreign lpvm access(~$#0:mytree.tree, 16:wybe.int, ?right#0:mytree.tree)
        foreign llvm move(1:wybe.bool, ?$$#0:wybe.bool)



right > public inline test (0 calls)
0: right($rec#0:mytree.tree, ?$#0:mytree.tree, ?$$#0:wybe.bool): AliasPairs: []
    foreign lpvm cast($rec#0:mytree.tree, ?tmp$0#0:wybe.int)
    foreign llvm icmp ne(~tmp$0#0:wybe.int, 0:wybe.int, ?tmp$1#0:wybe.bool)
    case ~tmp$1#0:wybe.bool of
    0:
        foreign llvm move(0:wybe.bool, ?$$#0:wybe.bool)

    1:
        foreign lpvm access(~$rec#0:mytree.tree, 16:wybe.int, ?$#0:mytree.tree)
        foreign llvm move(1:wybe.bool, ?$$#0:wybe.bool)

right > public inline test (0 calls)
1: right($rec#0:mytree.tree, ?$rec#1:mytree.tree, $field#0:mytree.tree, ?$$#0:wybe.bool): AliasPairs: []
    foreign lpvm cast($rec#0:mytree.tree, ?tmp$0#0:wybe.int)
    foreign llvm icmp ne(~tmp$0#0:wybe.int, 0:wybe.int, ?tmp$1#0:wybe.bool)
    case ~tmp$1#0:wybe.bool of
    0:
        foreign llvm move(0:wybe.bool, ?$$#0:wybe.bool)
        foreign llvm move(~$rec#0:mytree.tree, ?$rec#1:mytree.tree)

    1:
        foreign lpvm mutate(~%$rec#0:mytree.tree, ?%$rec#1:mytree.tree, 24:wybe.int, 16:wybe.int, 0:wybe.int, ~$field#0:mytree.tree)
        foreign llvm move(1:wybe.bool, ?$$#0:wybe.bool)


  LLVM code       :

; ModuleID = 'mytree.tree'


declare external ccc i8* @wybe_malloc(i32)

declare external ccc void @llvm.memcpy.p0i8.p0i8.i32(i8*, i8*, i32, i1)

define external ccc i1 @"mytree.tree.=<0>"(i64* %"$left#0", i64* %"$right#0"){
entry:
  %1 = ptrtoint i64* %"$left#0" to i64
  %"tmp$1#0" = icmp eq i64 %1, 0
  br i1 %"tmp$1#0", label %if.then, label %if.else
if.then:
  %"$$#0" = icmp eq i64* %"$left#0", %"$right#0"
  ret i1 %"$$#0"
if.else:
  %"tmp$10#0" = icmp ne i64 %1, 0
  br i1 %"tmp$10#0", label %if.then1, label %if.else1
if.then1:
  %2 = bitcast i64* %"$left#0" to i64**
  %3 = getelementptr i64*, i64** %2, i64 0
  %4 = load i64*, i64** %3
  %5 = inttoptr i64* %4 to i64*
  %6 = bitcast i64* %"$left#0" to i64*
  %7 = getelementptr i64, i64* %6, i64 1
  %8 = load i64, i64* %7
  %9 = bitcast i64* %"$left#0" to i64**
  %10 = getelementptr i64*, i64** %9, i64 2
  %11 = load i64*, i64** %10
  %12 = inttoptr i64* %11 to i64*
  %13 = ptrtoint i64* %"$right#0" to i64
  %"tmp$13#0" = icmp ne i64 %13, 0
  br i1 %"tmp$13#0", label %if.then2, label %if.else2
if.else1:
  ret i1 %"tmp$10#0"
if.then2:
  %14 = bitcast i64* %"$right#0" to i64**
  %15 = getelementptr i64*, i64** %14, i64 0
  %16 = load i64*, i64** %15
  %17 = inttoptr i64* %16 to i64*
  %18 = bitcast i64* %"$right#0" to i64*
  %19 = getelementptr i64, i64* %18, i64 1
  %20 = load i64, i64* %19
  %21 = bitcast i64* %"$right#0" to i64**
  %22 = getelementptr i64*, i64** %21, i64 2
  %23 = load i64*, i64** %22
  %24 = inttoptr i64* %23 to i64*
  %"tmp$5#0" = tail call ccc i1 @"mytree.tree.=<0>"(i64* %5, i64* %17)
  br i1 %"tmp$5#0", label %if.then3, label %if.else3
if.else2:
  ret i1 %"tmp$13#0"
if.then3:
  %"tmp$6#0" = icmp eq i64 %8, %20
  br i1 %"tmp$6#0", label %if.then4, label %if.else4
if.else3:
  ret i1 %"tmp$5#0"
if.then4:
  %"$$#0" = tail call ccc i1 @"mytree.tree.=<0>"(i64* %12, i64* %24)
  ret i1 %"$$#0"
if.else4:
  ret i1 %"tmp$6#0"
}

define external ccc i64* @"mytree.tree.empty<0>"(){
entry:
  ret i64 0
}

define external ccc {i64, i1} @"mytree.tree.key<0>"(i64* %"$rec#0"){
entry:
  %25 = ptrtoint i64* %"$rec#0" to i64
  %"tmp$1#0" = icmp ne i64 %25, 0
  br i1 %"tmp$1#0", label %if.then, label %if.else
if.then:
  %26 = bitcast i64* %"$rec#0" to i64*
  %27 = getelementptr i64, i64* %26, i64 1
  %28 = load i64, i64* %27
  %29 = insertvalue {i64, i1} undef, i64 %28, 0
  %30 = insertvalue {i64, i1} %29, i1 1, 1
  ret i1 1
if.else:
  %31 = insertvalue {i64, i1} undef, i64 %28, 0
  %32 = insertvalue {i64, i1} %31, i1 0, 1
  ret i1 0
}

define external ccc {i64*, i1} @"mytree.tree.key<1>"(i64* %"$rec#0", i64 %"$field#0"){
entry:
  %33 = ptrtoint i64* %"$rec#0" to i64
  %"tmp$1#0" = icmp ne i64 %33, 0
  br i1 %"tmp$1#0", label %if.then, label %if.else
if.then:
  %34 = tail call ccc i8* @wybe_malloc(i32 24)
  %35 = bitcast i8* %34 to i64*
  %36 = bitcast i64* %35 to i8*
  %37 = bitcast i64* %"$rec#0" to i8*
  tail call ccc void @llvm.memcpy.p0i8.p0i8.i32(i8* %36, i8* %37, i32 24, i1 0)
  %38 = bitcast i64* %35 to i64*
  %39 = getelementptr i64, i64* %38, i64 1
  store i64 %"$field#0", i64* %39
  %40 = insertvalue {i64*, i1} undef, i64* %35, 0
  %41 = insertvalue {i64*, i1} %40, i1 1, 1
  ret i1 1
if.else:
  %42 = insertvalue {i64*, i1} undef, i64* %"$rec#0", 0
  %43 = insertvalue {i64*, i1} %42, i1 0, 1
  ret i64* %"$rec#0"
}

define external ccc {i64*, i1} @"mytree.tree.left<0>"(i64* %"$rec#0"){
entry:
  %44 = ptrtoint i64* %"$rec#0" to i64
  %"tmp$1#0" = icmp ne i64 %44, 0
  br i1 %"tmp$1#0", label %if.then, label %if.else
if.then:
  %45 = bitcast i64* %"$rec#0" to i64**
  %46 = getelementptr i64*, i64** %45, i64 0
  %47 = load i64*, i64** %46
  %48 = inttoptr i64* %47 to i64*
  %49 = insertvalue {i64*, i1} undef, i64* %48, 0
  %50 = insertvalue {i64*, i1} %49, i1 1, 1
  ret i1 1
if.else:
  %51 = insertvalue {i64*, i1} undef, i64* %48, 0
  %52 = insertvalue {i64*, i1} %51, i1 0, 1
  ret i1 0
}

define external ccc {i64*, i1} @"mytree.tree.left<1>"(i64* %"$rec#0", i64* %"$field#0"){
entry:
  %53 = ptrtoint i64* %"$rec#0" to i64
  %"tmp$1#0" = icmp ne i64 %53, 0
  br i1 %"tmp$1#0", label %if.then, label %if.else
if.then:
  %54 = tail call ccc i8* @wybe_malloc(i32 24)
  %55 = bitcast i8* %54 to i64*
  %56 = bitcast i64* %55 to i8*
  %57 = bitcast i64* %"$rec#0" to i8*
  tail call ccc void @llvm.memcpy.p0i8.p0i8.i32(i8* %56, i8* %57, i32 24, i1 0)
  %58 = bitcast i64* %55 to i64**
  %59 = getelementptr i64*, i64** %58, i64 0
  store i64* %"$field#0", i64** %59
  %60 = insertvalue {i64*, i1} undef, i64* %55, 0
  %61 = insertvalue {i64*, i1} %60, i1 1, 1
  ret i1 1
if.else:
  %62 = insertvalue {i64*, i1} undef, i64* %"$rec#0", 0
  %63 = insertvalue {i64*, i1} %62, i1 0, 1
  ret i64* %"$rec#0"
}

define external ccc i64* @"mytree.tree.node<0>"(i64* %"left#0", i64 %"key#0", i64* %"right#0"){
entry:
  %64 = tail call ccc i8* @wybe_malloc(i32 24)
  %65 = bitcast i8* %64 to i64*
  %66 = bitcast i64* %65 to i64**
  %67 = getelementptr i64*, i64** %66, i64 0
  store i64* %"left#0", i64** %67
  %68 = bitcast i64* %65 to i64*
  %69 = getelementptr i64, i64* %68, i64 1
  store i64 %"key#0", i64* %69
  %70 = bitcast i64* %65 to i64**
  %71 = getelementptr i64*, i64** %70, i64 2
  store i64* %"right#0", i64** %71
  ret i64* %65
}

define external ccc {i64*, i64, i64*, i1} @"mytree.tree.node<1>"(i64* %"$#0"){
entry:
  %72 = ptrtoint i64* %"$#0" to i64
  %"tmp$1#0" = icmp ne i64 %72, 0
  br i1 %"tmp$1#0", label %if.then, label %if.else
if.then:
  %73 = bitcast i64* %"$#0" to i64**
  %74 = getelementptr i64*, i64** %73, i64 0
  %75 = load i64*, i64** %74
  %76 = inttoptr i64* %75 to i64*
  %77 = bitcast i64* %"$#0" to i64*
  %78 = getelementptr i64, i64* %77, i64 1
  %79 = load i64, i64* %78
  %80 = bitcast i64* %"$#0" to i64**
  %81 = getelementptr i64*, i64** %80, i64 2
  %82 = load i64*, i64** %81
  %83 = inttoptr i64* %82 to i64*
  %84 = insertvalue {i64*, i64, i64*, i1} undef, i64* %76, 0
  %85 = insertvalue {i64*, i64, i64*, i1} %84, i64 %79, 1
  %86 = insertvalue {i64*, i64, i64*, i1} %85, i64* %83, 2
  %87 = insertvalue {i64*, i64, i64*, i1} %86, i1 1, 3
  ret i1 1
if.else:
  %88 = insertvalue {i64*, i64, i64*, i1} undef, i64* %76, 0
  %89 = insertvalue {i64*, i64, i64*, i1} %88, i64 %79, 1
  %90 = insertvalue {i64*, i64, i64*, i1} %89, i64* %83, 2
  %91 = insertvalue {i64*, i64, i64*, i1} %90, i1 0, 3
  ret i1 0
}

define external ccc {i64*, i1} @"mytree.tree.right<0>"(i64* %"$rec#0"){
entry:
  %92 = ptrtoint i64* %"$rec#0" to i64
  %"tmp$1#0" = icmp ne i64 %92, 0
  br i1 %"tmp$1#0", label %if.then, label %if.else
if.then:
  %93 = bitcast i64* %"$rec#0" to i64**
  %94 = getelementptr i64*, i64** %93, i64 2
  %95 = load i64*, i64** %94
  %96 = inttoptr i64* %95 to i64*
  %97 = insertvalue {i64*, i1} undef, i64* %96, 0
  %98 = insertvalue {i64*, i1} %97, i1 1, 1
  ret i1 1
if.else:
  %99 = insertvalue {i64*, i1} undef, i64* %96, 0
  %100 = insertvalue {i64*, i1} %99, i1 0, 1
  ret i1 0
}

define external ccc {i64*, i1} @"mytree.tree.right<1>"(i64* %"$rec#0", i64* %"$field#0"){
entry:
  %101 = ptrtoint i64* %"$rec#0" to i64
  %"tmp$1#0" = icmp ne i64 %101, 0
  br i1 %"tmp$1#0", label %if.then, label %if.else
if.then:
  %102 = tail call ccc i8* @wybe_malloc(i32 24)
  %103 = bitcast i8* %102 to i64*
  %104 = bitcast i64* %103 to i8*
  %105 = bitcast i64* %"$rec#0" to i8*
  tail call ccc void @llvm.memcpy.p0i8.p0i8.i32(i8* %104, i8* %105, i32 24, i1 0)
  %106 = bitcast i64* %103 to i64**
  %107 = getelementptr i64*, i64** %106, i64 2
  store i64* %"$field#0", i64** %107
  %108 = insertvalue {i64*, i1} undef, i64* %103, 0
  %109 = insertvalue {i64*, i1} %108, i1 1, 1
  ret i1 1
if.else:
  %110 = insertvalue {i64*, i1} undef, i64* %"$rec#0", 0
  %111 = insertvalue {i64*, i1} %110, i1 0, 1
  ret i64* %"$rec#0"
}
