======================================================================
AFTER EVERYTHING:
 Module alias_fork1
  public submods  : 
  public types    : 
  public resources: 
  public procs    : alias_fork1.<0>
                    alias_fork1.simpleMerge<0>
  imports         : use mytree
                    use wybe
  types           : 
  resources       : 
  procs           : 

*main* > public (0 calls)
0: (wybe.io$io#0:wybe.phantom, ?wybe.io$io#1:wybe.phantom): AliasPairs: []
    foreign lpvm cast(0:mytree.tree, ?tmp$1#0:mytree.tree)
    foreign lpvm alloc(24:wybe.int, ?tmp$10#0:mytree.tree)
    foreign lpvm mutate(~tmp$10#0:mytree.tree, ?tmp$11#0:mytree.tree, 24:wybe.int, 0:wybe.int, 1:wybe.int, tmp$1#0:mytree.tree)
    foreign lpvm mutate(~tmp$11#0:mytree.tree, ?tmp$12#0:mytree.tree, 24:wybe.int, 8:wybe.int, 1:wybe.int, 222:wybe.int)
    foreign lpvm mutate(~tmp$12#0:mytree.tree, ?tmp$0#0:mytree.tree, 24:wybe.int, 16:wybe.int, 1:wybe.int, tmp$1#0:mytree.tree)
    foreign lpvm alloc(24:wybe.int, ?tmp$17#0:mytree.tree)
    foreign lpvm mutate(~tmp$17#0:mytree.tree, ?tmp$18#0:mytree.tree, 24:wybe.int, 0:wybe.int, 1:wybe.int, tmp$1#0:mytree.tree)
    foreign lpvm mutate(~tmp$18#0:mytree.tree, ?tmp$19#0:mytree.tree, 24:wybe.int, 8:wybe.int, 1:wybe.int, 111:wybe.int)
    foreign lpvm mutate(~tmp$19#0:mytree.tree, ?tmp$3#0:mytree.tree, 24:wybe.int, 16:wybe.int, 1:wybe.int, ~tmp$1#0:mytree.tree)
    alias_fork1.simpleMerge<0>(~tmp$0#0:mytree.tree, ~tmp$3#0:mytree.tree, ?tmp$6#0:mytree.tree) @alias_fork1:16:6
    mytree.printTree<0>(~tmp$6#0:mytree.tree, ~#wybe.io$io#0:wybe.phantom, ?#wybe.io$io#1:wybe.phantom) @alias_fork1:17:2


simpleMerge > public (1 calls)
0: simpleMerge(tl#0:mytree.tree, tr#0:mytree.tree, ?$#0:mytree.tree): AliasPairs: []
    foreign lpvm cast(tl#0:mytree.tree, ?tmp$18#0:wybe.int)
    foreign llvm icmp ne(~tmp$18#0:wybe.int, 0:wybe.int, ?tmp$19#0:wybe.bool)
    case ~tmp$19#0:wybe.bool of
    0:
        foreign lpvm cast(0:mytree.tree, ?tmp$11#0:mytree.tree)
        foreign lpvm alloc(24:wybe.int, ?tmp$23#0:mytree.tree)
        foreign lpvm mutate(~tmp$23#0:mytree.tree, ?tmp$24#0:mytree.tree, 24:wybe.int, 0:wybe.int, 1:wybe.int, tmp$11#0:mytree.tree)
        foreign lpvm mutate(~tmp$24#0:mytree.tree, ?tmp$25#0:mytree.tree, 24:wybe.int, 8:wybe.int, 1:wybe.int, 0:wybe.int)
        foreign lpvm mutate(~tmp$25#0:mytree.tree, ?$#0:mytree.tree, 24:wybe.int, 16:wybe.int, 1:wybe.int, ~tmp$11#0:mytree.tree)

    1:
        foreign lpvm access(tl#0:mytree.tree, 8:wybe.int, ?k1#0:wybe.int)
        foreign lpvm access(tl#0:mytree.tree, 16:wybe.int, ?r1#0:mytree.tree)
        foreign lpvm cast(tr#0:mytree.tree, ?tmp$22#0:wybe.int)
        foreign llvm icmp ne(~tmp$22#0:wybe.int, 0:wybe.int, ?tmp$23#0:wybe.bool)
        case ~tmp$23#0:wybe.bool of
        0:
            foreign lpvm cast(0:mytree.tree, ?tmp$8#0:mytree.tree)
            foreign lpvm alloc(24:wybe.int, ?tmp$27#0:mytree.tree)
            foreign lpvm mutate(~tmp$27#0:mytree.tree, ?tmp$28#0:mytree.tree, 24:wybe.int, 0:wybe.int, 1:wybe.int, tmp$8#0:mytree.tree)
            foreign lpvm mutate(~tmp$28#0:mytree.tree, ?tmp$29#0:mytree.tree, 24:wybe.int, 8:wybe.int, 1:wybe.int, 0:wybe.int)
            foreign lpvm mutate(~tmp$29#0:mytree.tree, ?$#0:mytree.tree, 24:wybe.int, 16:wybe.int, 1:wybe.int, ~tmp$8#0:mytree.tree)

        1:
            foreign lpvm access(tr#0:mytree.tree, 8:wybe.int, ?k2#0:wybe.int)
            foreign lpvm access(tr#0:mytree.tree, 16:wybe.int, ?r2#0:mytree.tree)
            foreign llvm icmp slt(k1#0:wybe.int, k2#0:wybe.int, ?tmp$15#0:wybe.bool) @wybe:24:39
            case ~tmp$15#0:wybe.bool of
            0:
                foreign lpvm alloc(24:wybe.int, ?tmp$29#0:mytree.tree)
                foreign lpvm mutate(~tmp$29#0:mytree.tree, ?tmp$30#0:mytree.tree, 24:wybe.int, 0:wybe.int, 1:wybe.int, ~tr#0:mytree.tree)
                foreign lpvm mutate(~tmp$30#0:mytree.tree, ?tmp$31#0:mytree.tree, 24:wybe.int, 8:wybe.int, 1:wybe.int, ~k1#0:wybe.int)
                foreign lpvm mutate(~tmp$31#0:mytree.tree, ?$#0:mytree.tree, 24:wybe.int, 16:wybe.int, 1:wybe.int, ~r1#0:mytree.tree)

            1:
                foreign lpvm alloc(24:wybe.int, ?tmp$29#0:mytree.tree)
                foreign lpvm mutate(~tmp$29#0:mytree.tree, ?tmp$30#0:mytree.tree, 24:wybe.int, 0:wybe.int, 1:wybe.int, ~tl#0:mytree.tree)
                foreign lpvm mutate(~tmp$30#0:mytree.tree, ?tmp$31#0:mytree.tree, 24:wybe.int, 8:wybe.int, 1:wybe.int, ~k2#0:wybe.int)
                foreign lpvm mutate(~tmp$31#0:mytree.tree, ?$#0:mytree.tree, 24:wybe.int, 16:wybe.int, 1:wybe.int, ~r2#0:mytree.tree)



--------------------------------------------------
 Module mytree
  public submods  : 
  public types    : tree: (mytree.tree,"pointer")
  public resources: 
  public procs    : mytree.printTree<0>
                    mytree.tree.=<0>
                    mytree.tree.=<1>
                    mytree.tree.=<2>
                    mytree.tree.empty<0>
                    mytree.tree.key<0>
                    mytree.tree.key<1>
                    mytree.tree.left<0>
                    mytree.tree.left<1>
                    mytree.tree.node<0>
                    mytree.tree.node<1>
                    mytree.tree.right<0>
                    mytree.tree.right<1>
  imports         : public use mytree.tree
                    use wybe
  types           : tree/0 (pointer)  @mytree:1:8
  resources       : 
  procs           : 

printTree > public (2 calls)
0: printTree(t#0:mytree.tree, wybe.io$io#0:wybe.phantom, ?wybe.io$io#3:wybe.phantom): AliasPairs: []
    foreign lpvm cast(t#0:mytree.tree, ?tmp$4#0:wybe.int)
    foreign llvm icmp ne(~tmp$4#0:wybe.int, 0:wybe.int, ?tmp$5#0:wybe.bool)
    case ~tmp$5#0:wybe.bool of
    0:
        foreign llvm move(~wybe.io$io#0:wybe.phantom, ?wybe.io$io#3:wybe.phantom)

    1:
        foreign lpvm access(t#0:mytree.tree, 0:wybe.int, ?l#0:mytree.tree)
        foreign lpvm access(t#0:mytree.tree, 8:wybe.int, ?k#0:wybe.int)
        foreign lpvm access(~t#0:mytree.tree, 16:wybe.int, ?r#0:mytree.tree)
        mytree.printTree<0>(~l#0:mytree.tree, ~#wybe.io$io#0:wybe.phantom, ?#wybe.io$io#1:wybe.phantom) @mytree:5:6
        foreign c print_int(~k#0:wybe.int, ~#wybe.io$io#1:wybe.phantom, ?tmp$8#0:wybe.phantom) @wybe:80:38
        foreign c putchar('\n':wybe.char, ~tmp$8#0:wybe.phantom, ?#wybe.io$io#2:wybe.phantom) @wybe:78:28
        mytree.printTree<0>(~r#0:mytree.tree, ~#wybe.io$io#2:wybe.phantom, ?#wybe.io$io#3:wybe.phantom) @mytree:7:6

  submodules      : mytree.tree
--------------------------------------------------
 Module mytree.tree([])
  public submods  : 
  public types    : 
  public resources: 
  public procs    : mytree.tree.=<0>
                    mytree.tree.=<1>
                    mytree.tree.=<2>
                    mytree.tree.empty<0>
                    mytree.tree.key<0>
                    mytree.tree.key<1>
                    mytree.tree.left<0>
                    mytree.tree.left<1>
                    mytree.tree.node<0>
                    mytree.tree.node<1>
                    mytree.tree.right<0>
                    mytree.tree.right<1>
  imports         : use mytree
                    use wybe
  types           : 
  resources       : 
  procs           : 

= > public inline (0 calls)
0: =(?out#0:mytree.tree, in#0:mytree.tree): AliasPairs: []
    foreign llvm move(~in#0:mytree.tree, ?out#0:mytree.tree)
= > public inline (0 calls)
1: =(in#0:mytree.tree, ?out#0:mytree.tree): AliasPairs: []
    foreign llvm move(~in#0:mytree.tree, ?out#0:mytree.tree)
= > public test (6 calls)
2: =($left#0:mytree.tree, $right#0:mytree.tree, ?$$#0:wybe.bool): AliasPairs: [($left#0,$left$left#0),($right#0,$right$left#0)]
    foreign lpvm cast($left#0:mytree.tree, ?tmp$0#0:wybe.int)
    foreign llvm icmp eq(tmp$0#0:wybe.int, 0:wybe.int, ?tmp$1#0:wybe.bool)
    case ~tmp$1#0:wybe.bool of
    0:
        foreign llvm icmp ne(~tmp$0#0:wybe.int, 0:wybe.int, ?tmp$10#0:wybe.bool)
        case ~tmp$10#0:wybe.bool of
        0:
            foreign llvm move(0:wybe.bool, ?$$#0:wybe.bool)

        1:
            foreign lpvm access($left#0:mytree.tree, 0:wybe.int, ?$left$left#0:mytree.tree)
            foreign lpvm access($left#0:mytree.tree, 8:wybe.int, ?$left$key#0:wybe.int)
            foreign lpvm access(~$left#0:mytree.tree, 16:wybe.int, ?$left$right#0:mytree.tree)
            foreign lpvm cast($right#0:mytree.tree, ?tmp$12#0:wybe.int)
            foreign llvm icmp ne(~tmp$12#0:wybe.int, 0:wybe.int, ?tmp$13#0:wybe.bool)
            case ~tmp$13#0:wybe.bool of
            0:
                foreign llvm move(0:wybe.bool, ?$$#0:wybe.bool)

            1:
                foreign lpvm access($right#0:mytree.tree, 0:wybe.int, ?$right$left#0:mytree.tree)
                foreign lpvm access($right#0:mytree.tree, 8:wybe.int, ?$right$key#0:wybe.int)
                foreign lpvm access(~$right#0:mytree.tree, 16:wybe.int, ?$right$right#0:mytree.tree)
                mytree.tree.=<2>(~$left$left#0:mytree.tree, ~$right$left#0:mytree.tree, ?tmp$5#0:wybe.bool)
                case ~tmp$5#0:wybe.bool of
                0:
                    foreign llvm move(0:wybe.bool, ?$$#0:wybe.bool)

                1:
                    foreign llvm icmp eq(~$left$key#0:wybe.int, ~$right$key#0:wybe.int, ?tmp$6#0:wybe.bool) @wybe:28:40
                    case ~tmp$6#0:wybe.bool of
                    0:
                        foreign llvm move(0:wybe.bool, ?$$#0:wybe.bool)

                    1:
                        mytree.tree.=<2>(~$left$right#0:mytree.tree, ~$right$right#0:mytree.tree, ?$$#0:wybe.bool)





    1:
        foreign llvm icmp eq(~$left#0:wybe.int, ~$right#0:wybe.int, ?$$#0:wybe.bool)



empty > public inline (0 calls)
0: empty(?$#0:mytree.tree): AliasPairs: []
    foreign lpvm cast(0:mytree.tree, ?$#0:mytree.tree)


key > public inline test (0 calls)
0: key($rec#0:mytree.tree, ?$#0:wybe.int, ?$$#0:wybe.bool): AliasPairs: []
    foreign lpvm cast($rec#0:mytree.tree, ?tmp$0#0:wybe.int)
    foreign llvm icmp ne(~tmp$0#0:wybe.int, 0:wybe.int, ?tmp$1#0:wybe.bool)
    case ~tmp$1#0:wybe.bool of
    0:
        foreign llvm move(0:wybe.bool, ?$$#0:wybe.bool)

    1:
        foreign lpvm access(~$rec#0:mytree.tree, 8:wybe.int, ?$#0:wybe.int)
        foreign llvm move(1:wybe.bool, ?$$#0:wybe.bool)

key > public inline test (0 calls)
1: key($rec#0:mytree.tree, ?$rec#1:mytree.tree, $field#0:wybe.int, ?$$#0:wybe.bool): AliasPairs: []
    foreign lpvm cast($rec#0:mytree.tree, ?tmp$0#0:wybe.int)
    foreign llvm icmp ne(~tmp$0#0:wybe.int, 0:wybe.int, ?tmp$1#0:wybe.bool)
    case ~tmp$1#0:wybe.bool of
    0:
        foreign llvm move(0:wybe.bool, ?$$#0:wybe.bool)
        foreign llvm move(~$rec#0:mytree.tree, ?$rec#1:mytree.tree)

    1:
        foreign lpvm mutate(~%$rec#0:mytree.tree, ?%$rec#1:mytree.tree, 24:wybe.int, 8:wybe.int, 0:wybe.int, ~$field#0:wybe.int)
        foreign llvm move(1:wybe.bool, ?$$#0:wybe.bool)



left > public inline test (0 calls)
0: left($rec#0:mytree.tree, ?$#0:mytree.tree, ?$$#0:wybe.bool): AliasPairs: []
    foreign lpvm cast($rec#0:mytree.tree, ?tmp$0#0:wybe.int)
    foreign llvm icmp ne(~tmp$0#0:wybe.int, 0:wybe.int, ?tmp$1#0:wybe.bool)
    case ~tmp$1#0:wybe.bool of
    0:
        foreign llvm move(0:wybe.bool, ?$$#0:wybe.bool)

    1:
        foreign lpvm access(~$rec#0:mytree.tree, 0:wybe.int, ?$#0:mytree.tree)
        foreign llvm move(1:wybe.bool, ?$$#0:wybe.bool)

left > public inline test (0 calls)
1: left($rec#0:mytree.tree, ?$rec#1:mytree.tree, $field#0:mytree.tree, ?$$#0:wybe.bool): AliasPairs: []
    foreign lpvm cast($rec#0:mytree.tree, ?tmp$0#0:wybe.int)
    foreign llvm icmp ne(~tmp$0#0:wybe.int, 0:wybe.int, ?tmp$1#0:wybe.bool)
    case ~tmp$1#0:wybe.bool of
    0:
        foreign llvm move(0:wybe.bool, ?$$#0:wybe.bool)
        foreign llvm move(~$rec#0:mytree.tree, ?$rec#1:mytree.tree)

    1:
        foreign lpvm mutate(~%$rec#0:mytree.tree, ?%$rec#1:mytree.tree, 24:wybe.int, 0:wybe.int, 0:wybe.int, ~$field#0:mytree.tree)
        foreign llvm move(1:wybe.bool, ?$$#0:wybe.bool)



node > public inline (0 calls)
0: node(left#0:mytree.tree, key#0:wybe.int, right#0:mytree.tree, ?$#0:mytree.tree): AliasPairs: []
    foreign lpvm alloc(24:wybe.int, ?$rec#0:mytree.tree)
    foreign lpvm mutate(~%$rec#0:mytree.tree, ?%$rec#1:mytree.tree, 24:wybe.int, 0:wybe.int, 1:wybe.int, ~left#0:mytree.tree)
    foreign lpvm mutate(~%$rec#1:mytree.tree, ?%$rec#2:mytree.tree, 24:wybe.int, 8:wybe.int, 1:wybe.int, ~key#0:wybe.int)
    foreign lpvm mutate(~%$rec#2:mytree.tree, ?%$#0:mytree.tree, 24:wybe.int, 16:wybe.int, 1:wybe.int, ~right#0:mytree.tree)
node > public inline test (9 calls)
1: node(?left#0:mytree.tree, ?key#0:wybe.int, ?right#0:mytree.tree, $#0:mytree.tree, ?$$#0:wybe.bool): AliasPairs: []
    foreign lpvm cast($#0:mytree.tree, ?tmp$0#0:wybe.int)
    foreign llvm icmp ne(~tmp$0#0:wybe.int, 0:wybe.int, ?tmp$1#0:wybe.bool)
    case ~tmp$1#0:wybe.bool of
    0:
        foreign llvm move(0:wybe.bool, ?$$#0:wybe.bool)

    1:
        foreign lpvm access($#0:mytree.tree, 0:wybe.int, ?left#0:mytree.tree)
        foreign lpvm access($#0:mytree.tree, 8:wybe.int, ?key#0:wybe.int)
        foreign lpvm access(~$#0:mytree.tree, 16:wybe.int, ?right#0:mytree.tree)
        foreign llvm move(1:wybe.bool, ?$$#0:wybe.bool)



right > public inline test (0 calls)
0: right($rec#0:mytree.tree, ?$#0:mytree.tree, ?$$#0:wybe.bool): AliasPairs: []
    foreign lpvm cast($rec#0:mytree.tree, ?tmp$0#0:wybe.int)
    foreign llvm icmp ne(~tmp$0#0:wybe.int, 0:wybe.int, ?tmp$1#0:wybe.bool)
    case ~tmp$1#0:wybe.bool of
    0:
        foreign llvm move(0:wybe.bool, ?$$#0:wybe.bool)

    1:
        foreign lpvm access(~$rec#0:mytree.tree, 16:wybe.int, ?$#0:mytree.tree)
        foreign llvm move(1:wybe.bool, ?$$#0:wybe.bool)

right > public inline test (0 calls)
1: right($rec#0:mytree.tree, ?$rec#1:mytree.tree, $field#0:mytree.tree, ?$$#0:wybe.bool): AliasPairs: []
    foreign lpvm cast($rec#0:mytree.tree, ?tmp$0#0:wybe.int)
    foreign llvm icmp ne(~tmp$0#0:wybe.int, 0:wybe.int, ?tmp$1#0:wybe.bool)
    case ~tmp$1#0:wybe.bool of
    0:
        foreign llvm move(0:wybe.bool, ?$$#0:wybe.bool)
        foreign llvm move(~$rec#0:mytree.tree, ?$rec#1:mytree.tree)

    1:
        foreign lpvm mutate(~%$rec#0:mytree.tree, ?%$rec#1:mytree.tree, 24:wybe.int, 16:wybe.int, 0:wybe.int, ~$field#0:mytree.tree)
        foreign llvm move(1:wybe.bool, ?$$#0:wybe.bool)

alias_fork1, mytree, mytree.tree
======================================================================
AFTER LLVM IR:

; ModuleID = 'alias_fork1'
source_filename = "test-cases/alias_fork1.wybe"

declare void @"mytree.printTree<0>"(i64*) local_unnamed_addr

declare i8* @wybe_malloc(i32) local_unnamed_addr

define i32 @alias_fork1.main() local_unnamed_addr {
entry:
  %0 = tail call i8* @wybe_malloc(i32 24)
  %1 = bitcast i8* %0 to i64*
  %2 = bitcast i8* %0 to i64**
  store i64* null, i64** %2, align 8
  %3 = getelementptr i8, i8* %0, i64 8
  %4 = bitcast i8* %3 to i64*
  store i64 222, i64* %4, align 4
  %5 = getelementptr i8, i8* %0, i64 16
  %6 = bitcast i8* %5 to i64**
  store i64* null, i64** %6, align 8
  %7 = tail call i8* @wybe_malloc(i32 24)
  %8 = bitcast i8* %7 to i64*
  %9 = bitcast i8* %7 to i64**
  store i64* null, i64** %9, align 8
  %10 = getelementptr i8, i8* %7, i64 8
  %11 = bitcast i8* %10 to i64*
  store i64 111, i64* %11, align 4
  %12 = getelementptr i8, i8* %7, i64 16
  %13 = bitcast i8* %12 to i64**
  store i64* null, i64** %13, align 8
  %"tmp$6#0" = tail call i64* @"alias_fork1.simpleMerge<0>"(i64* %1, i64* %8)
  tail call void @"mytree.printTree<0>"(i64* %"tmp$6#0")
  ret i32 0
}

define i64* @"alias_fork1.simpleMerge<0>"(i64*, i64*) local_unnamed_addr {
entry:
  %"tmp$19#0" = icmp eq i64* %0, null
  br i1 %"tmp$19#0", label %if.else, label %if.then

if.then:                                          ; preds = %entry
  %2 = getelementptr i64, i64* %0, i64 1
  %3 = load i64, i64* %2, align 4
  %4 = getelementptr i64, i64* %0, i64 2
  %5 = bitcast i64* %4 to i64**
  %6 = load i64*, i64** %5, align 8
  %"tmp$23#0" = icmp eq i64* %1, null
  br i1 %"tmp$23#0", label %if.else1, label %if.then1

if.else:                                          ; preds = %entry
  %7 = tail call i8* @wybe_malloc(i32 24)
  %8 = bitcast i8* %7 to i64*
  call void @llvm.memset.p0i8.i64(i8* %7, i8 0, i64 24, i32 8, i1 false)
  ret i64* %8

if.then1:                                         ; preds = %if.then
  %9 = getelementptr i64, i64* %1, i64 1
  %10 = load i64, i64* %9, align 4
  %"tmp$15#0" = icmp slt i64 %3, %10
  br i1 %"tmp$15#0", label %if.then2, label %if.else2

if.else1:                                         ; preds = %if.then
  %11 = tail call i8* @wybe_malloc(i32 24)
  call void @llvm.memset.p0i8.i64(i8* %11, i8 0, i64 24, i32 8, i1 false)
  ret i1 false

if.then2:                                         ; preds = %if.then1
  %12 = getelementptr i64, i64* %1, i64 2
  %13 = bitcast i64* %12 to i64**
  %14 = load i64*, i64** %13, align 8
  %15 = tail call i8* @wybe_malloc(i32 24)
  %16 = bitcast i8* %15 to i64*
  %17 = bitcast i8* %15 to i64**
  store i64* %0, i64** %17, align 8
  %18 = getelementptr i8, i8* %15, i64 8
  %19 = bitcast i8* %18 to i64*
  store i64 %10, i64* %19, align 4
  %20 = getelementptr i8, i8* %15, i64 16
  %21 = bitcast i8* %20 to i64**
  store i64* %14, i64** %21, align 8
  ret i64* %16

if.else2:                                         ; preds = %if.then1
  %22 = tail call i8* @wybe_malloc(i32 24)
  %23 = bitcast i8* %22 to i64**
  store i64* %1, i64** %23, align 8
  %24 = getelementptr i8, i8* %22, i64 8
  %25 = bitcast i8* %24 to i64*
  store i64 %3, i64* %25, align 4
  %26 = getelementptr i8, i8* %22, i64 16
  %27 = bitcast i8* %26 to i64**
  store i64* %6, i64** %27, align 8
  ret i1 false
}

; Function Attrs: argmemonly nounwind
declare void @llvm.memset.p0i8.i64(i8* nocapture writeonly, i8, i64, i32, i1) #0

attributes #0 = { argmemonly nounwind }

--------------------------------------------------
; ModuleID = 'mytree'
source_filename = "test-cases/mytree.wybe"

declare void @putchar(i8) local_unnamed_addr

declare void @print_int(i64) local_unnamed_addr

define void @"mytree.printTree<0>"(i64* readonly) local_unnamed_addr {
entry:
  %"tmp$5#01" = icmp eq i64* %0, null
  br i1 %"tmp$5#01", label %if.else, label %if.then.preheader

if.then.preheader:                                ; preds = %entry
  br label %if.then

if.then:                                          ; preds = %if.then.preheader, %if.then
  %.tr2 = phi i64* [ %7, %if.then ], [ %0, %if.then.preheader ]
  %1 = bitcast i64* %.tr2 to i64**
  %2 = load i64*, i64** %1, align 8
  %3 = getelementptr i64, i64* %.tr2, i64 1
  %4 = load i64, i64* %3, align 4
  %5 = getelementptr i64, i64* %.tr2, i64 2
  %6 = bitcast i64* %5 to i64**
  %7 = load i64*, i64** %6, align 8
  tail call void @"mytree.printTree<0>"(i64* %2)
  tail call void @print_int(i64 %4)
  tail call void @putchar(i8 10)
  %"tmp$5#0" = icmp eq i64* %7, null
  br i1 %"tmp$5#0", label %if.else, label %if.then

if.else:                                          ; preds = %if.then, %entry
  ret void
}

--------------------------------------------------
; ModuleID = 'mytree.tree'
source_filename = "test-cases"

declare i8* @wybe_malloc(i32) local_unnamed_addr

declare void @llvm.memcpy.p0i8.p0i8.i32(i8*, i8*, i32, i1)

; Function Attrs: norecurse nounwind readnone
define i64* @"mytree.tree.=<0>"(i64* readnone returned %"in#0") local_unnamed_addr #0 {
entry:
  ret i64* %"in#0"
}

; Function Attrs: norecurse nounwind readnone
define i64* @"mytree.tree.=<1>"(i64* readnone returned %"in#0") local_unnamed_addr #0 {
entry:
  ret i64* %"in#0"
}

; Function Attrs: nounwind readonly
define i1 @"mytree.tree.=<2>"(i64* readonly, i64* readonly) local_unnamed_addr #1 {
entry:
  %"tmp$1#05" = icmp eq i64* %0, null
  br i1 %"tmp$1#05", label %if.then, label %if.then1.preheader

if.then1.preheader:                               ; preds = %entry
  br label %if.then1

if.then:                                          ; preds = %if.then4, %entry
  %.tr2.lcssa = phi i64* [ %1, %entry ], [ %15, %if.then4 ]
  %"$$#0" = icmp eq i64* %.tr2.lcssa, null
  ret i1 %"$$#0"

if.then1:                                         ; preds = %if.then1.preheader, %if.then4
  %.tr27 = phi i64* [ %15, %if.then4 ], [ %1, %if.then1.preheader ]
  %.tr6 = phi i64* [ %4, %if.then4 ], [ %0, %if.then1.preheader ]
  %2 = getelementptr i64, i64* %.tr6, i64 2
  %3 = bitcast i64* %2 to i64**
  %4 = load i64*, i64** %3, align 8
  %"tmp$13#0" = icmp eq i64* %.tr27, null
  br i1 %"tmp$13#0", label %if.else2, label %if.then2

if.then2:                                         ; preds = %if.then1
  %5 = getelementptr i64, i64* %.tr6, i64 1
  %6 = load i64, i64* %5, align 4
  %7 = bitcast i64* %.tr6 to i64**
  %8 = load i64*, i64** %7, align 8
  %9 = bitcast i64* %.tr27 to i64**
  %10 = load i64*, i64** %9, align 8
  %11 = getelementptr i64, i64* %.tr27, i64 1
  %12 = load i64, i64* %11, align 4
  %"tmp$5#0" = tail call i1 @"mytree.tree.=<2>"(i64* %8, i64* %10)
  %"tmp$6#0" = icmp eq i64 %6, %12
  %or.cond = and i1 %"tmp$5#0", %"tmp$6#0"
  br i1 %or.cond, label %if.then4, label %if.else2

if.else2:                                         ; preds = %if.then1, %if.then2
  ret i1 false

if.then4:                                         ; preds = %if.then2
  %13 = getelementptr i64, i64* %.tr27, i64 2
  %14 = bitcast i64* %13 to i64**
  %15 = load i64*, i64** %14, align 8
  %"tmp$1#0" = icmp eq i64* %4, null
  br i1 %"tmp$1#0", label %if.then, label %if.then1
}

; Function Attrs: norecurse nounwind readnone
define noalias i64* @"mytree.tree.empty<0>"() local_unnamed_addr #0 {
entry:
  ret i64* null
}

; Function Attrs: norecurse nounwind readnone
define { i64, i1 } @"mytree.tree.key<0>"(i64* readnone) local_unnamed_addr #0 {
entry:
  %"tmp$1#0" = icmp ne i64* %0, null
  ret i1 %"tmp$1#0"
}

define { i64*, i1 } @"mytree.tree.key<1>"(i64* %"$rec#0", i64 %"$field#0") local_unnamed_addr {
entry:
  %"tmp$1#0" = icmp eq i64* %"$rec#0", null
  br i1 %"tmp$1#0", label %if.else, label %if.then

if.then:                                          ; preds = %entry
  %0 = tail call i8* @wybe_malloc(i32 24)
  %1 = bitcast i64* %"$rec#0" to i8*
  tail call void @llvm.memcpy.p0i8.p0i8.i32(i8* %0, i8* %1, i32 24, i1 false)
  %2 = getelementptr i8, i8* %0, i64 8
  %3 = bitcast i8* %2 to i64*
  store i64 %"$field#0", i64* %3, align 4
  ret i1 true

if.else:                                          ; preds = %entry
  ret i64* null
}

; Function Attrs: norecurse nounwind readnone
define { i64*, i1 } @"mytree.tree.left<0>"(i64* readnone %"$rec#0") local_unnamed_addr #0 {
entry:
  %"tmp$1#0" = icmp ne i64* %"$rec#0", null
  ret i1 %"tmp$1#0"
}

define { i64*, i1 } @"mytree.tree.left<1>"(i64* %"$rec#0", i64* %"$field#0") local_unnamed_addr {
entry:
  %"tmp$1#0" = icmp eq i64* %"$rec#0", null
  br i1 %"tmp$1#0", label %if.else, label %if.then

if.then:                                          ; preds = %entry
  %0 = tail call i8* @wybe_malloc(i32 24)
  %1 = bitcast i64* %"$rec#0" to i8*
  tail call void @llvm.memcpy.p0i8.p0i8.i32(i8* %0, i8* %1, i32 24, i1 false)
  %2 = bitcast i8* %0 to i64**
  store i64* %"$field#0", i64** %2, align 8
  ret i1 true

if.else:                                          ; preds = %entry
  ret i64* null
}

define i64* @"mytree.tree.node<0>"(i64* %"left#0", i64 %"key#0", i64* %"right#0") local_unnamed_addr {
entry:
  %0 = tail call i8* @wybe_malloc(i32 24)
  %1 = bitcast i8* %0 to i64*
  %2 = bitcast i8* %0 to i64**
  store i64* %"left#0", i64** %2, align 8
  %3 = getelementptr i8, i8* %0, i64 8
  %4 = bitcast i8* %3 to i64*
  store i64 %"key#0", i64* %4, align 4
  %5 = getelementptr i8, i8* %0, i64 16
  %6 = bitcast i8* %5 to i64**
  store i64* %"right#0", i64** %6, align 8
  ret i64* %1
}

; Function Attrs: norecurse nounwind readnone
define { i64*, i64, i64*, i1 } @"mytree.tree.node<1>"(i64* readnone) local_unnamed_addr #0 {
entry:
  %"tmp$1#0" = icmp ne i64* %0, null
  ret i1 %"tmp$1#0"
}

; Function Attrs: norecurse nounwind readnone
define { i64*, i1 } @"mytree.tree.right<0>"(i64* readnone %"$rec#0") local_unnamed_addr #0 {
entry:
  %"tmp$1#0" = icmp ne i64* %"$rec#0", null
  ret i1 %"tmp$1#0"
}

define { i64*, i1 } @"mytree.tree.right<1>"(i64* %"$rec#0", i64* %"$field#0") local_unnamed_addr {
entry:
  %"tmp$1#0" = icmp eq i64* %"$rec#0", null
  br i1 %"tmp$1#0", label %if.else, label %if.then

if.then:                                          ; preds = %entry
  %0 = tail call i8* @wybe_malloc(i32 24)
  %1 = bitcast i64* %"$rec#0" to i8*
  tail call void @llvm.memcpy.p0i8.p0i8.i32(i8* %0, i8* %1, i32 24, i1 false)
  %2 = getelementptr i8, i8* %0, i64 16
  %3 = bitcast i8* %2 to i64**
  store i64* %"$field#0", i64** %3, align 8
  ret i1 true

if.else:                                          ; preds = %entry
  ret i64* null
}

attributes #0 = { norecurse nounwind readnone }
attributes #1 = { nounwind readonly }

