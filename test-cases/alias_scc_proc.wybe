# transitive aliasing data structures in nested proc calls

use position

# Expected Alias Pairs: [(p1, p2), (p1, p3), (p2, p3)]
public proc foo(p1:position, ?p2:position, ?p3:position) use !io
    if p1.x > 1 :: ?p2 = p1 # p1 and p2 aliased
                    ?p3 = position(3,3)
                    !print("p3:")
                    !printPosition(p3)
    | true :: ?tmp = p1.x
              x(!p1, tmp + 1)
              !bar(p1, ?p3) # p1(2,1), p1 and p3 aliased
              ?p2 = position(2,2)
    end
end

# Expected Alias Pairs: [(p1, p2)]
public proc bar(p1:position, ?p3:position) use !io
    if p1.y > 1 :: ?p3 = p1
    | true :: ?tmp = p1.y
              y(!p1, tmp + 1) # p1 (2, 2)
              ?p3 = p1
              !foo(p1, ?p2, ?p3)
    end
end

?p1 = position(1, 1)
!foo(p1, ?p2, ?p3)

!print("p1:")
!printPosition(p1)
!print("p2:")
!printPosition(p2)
!print("p3:")
!printPosition(p3) # (0,0)????