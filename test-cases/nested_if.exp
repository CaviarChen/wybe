======================================================================
AFTER EVERYTHING:
 Module nested_if
  public submods  : 
  public types    : 
  public resources: 
  public procs    : nested_if.nested_if<0>
  imports         : use wybe
  types           : 
  resources       : 
  procs           : 

nested_if > public (0 calls)
0: nested_if(i#0:wybe.int, io#0:phantom, ?io#1:phantom): AliasPairs: []
    foreign llvm icmp eq(i#0:wybe.int, 0:wybe.int, ?tmp$0#0:wybe.bool) @wybe:nn:nn
    case ~tmp$0#0:wybe.bool of
    0:
        foreign llvm icmp eq(i#0:wybe.int, 1001:wybe.int, ?tmp$1#0:wybe.bool) @wybe:nn:nn
        case ~tmp$1#0:wybe.bool of
        0:
            foreign llvm icmp eq(~i#0:wybe.int, 2:wybe.int, ?tmp$2#0:wybe.bool) @wybe:nn:nn
            case ~tmp$2#0:wybe.bool of
            0:
                foreign c print_string("other":wybe.string, ~#io#0:phantom, ?tmp$12#0:phantom) @wybe:nn:nn
                foreign c putchar('\n':wybe.char, ~tmp$12#0:phantom, ?#io#1:phantom) @wybe:nn:nn

            1:
                foreign c print_string("two":wybe.string, ~#io#0:phantom, ?tmp$12#0:phantom) @wybe:nn:nn
                foreign c putchar('\n':wybe.char, ~tmp$12#0:phantom, ?#io#1:phantom) @wybe:nn:nn


        1:
            foreign c print_string("one thousand and one":wybe.string, ~#io#0:phantom, ?tmp$10#0:phantom) @wybe:nn:nn
            foreign c putchar('\n':wybe.char, ~tmp$10#0:phantom, ?#io#1:phantom) @wybe:nn:nn


    1:
        foreign c print_string("zero":wybe.string, ~#io#0:phantom, ?tmp$8#0:phantom) @wybe:nn:nn
        foreign c putchar('\n':wybe.char, ~tmp$8#0:phantom, ?#io#1:phantom) @wybe:nn:nn


  LLVM code       :

; ModuleID = 'nested_if'


declare external ccc void @putchar(i8)

declare external ccc void @print_string(i8*)

@nested_if.4 = constant [6 x i8] c"other\00"

@nested_if.3 = constant [4 x i8] c"two\00"

@nested_if.2 = constant [21 x i8] c"one thousand and one\00"

@nested_if.1 = constant [5 x i8] c"zero\00"

declare external ccc i8* @wybe_malloc(i32)

declare external ccc void @llvm.memcpy.p0i8.p0i8.i32(i8*, i8*, i32, i1)

define external ccc void @"nested_if.nested_if<0>"(i64 %"i#0"){
entry:
  %"tmp$0#0" = icmp eq i64 %"i#0", 0
  br i1 %"tmp$0#0", label %if.then, label %if.else
if.then:
  tail call ccc void @print_string(i8* getelementptr inbounds ([5 x i8], [5 x i8]* @nested_if.1, i32 0, i32 0))
  tail call ccc void @putchar(i8 10)
  ret void
if.else:
  %"tmp$1#0" = icmp eq i64 %"i#0", 1001
  br i1 %"tmp$1#0", label %if.then1, label %if.else1
if.then1:
  tail call ccc void @print_string(i8* getelementptr inbounds ([21 x i8], [21 x i8]* @nested_if.2, i32 0, i32 0))
  tail call ccc void @putchar(i8 10)
  ret void
if.else1:
  %"tmp$2#0" = icmp eq i64 %"i#0", 2
  br i1 %"tmp$2#0", label %if.then2, label %if.else2
if.then2:
  tail call ccc void @print_string(i8* getelementptr inbounds ([4 x i8], [4 x i8]* @nested_if.3, i32 0, i32 0))
  tail call ccc void @putchar(i8 10)
  ret void
if.else2:
  tail call ccc void @print_string(i8* getelementptr inbounds ([6 x i8], [6 x i8]* @nested_if.4, i32 0, i32 0))
  tail call ccc void @putchar(i8 10)
  ret i1 %"tmp$1#0"
}
