Public type list(t) is {type-list:1:8}
  Public ctor [] {type-list:2:12}
  Public ctor [|](head:t,tail:list(t)) {type-list:3:12}
end

Public func ++(x:list(t),y:list(t)):? {type-list:6:8} = if ==(x {type-list:7:8}, []() {type-list:7:13}) {type-list:7:8} then y {type-list:8:10} else [|](head(x {type-list:9:11}) {type-list:9:11}, ++(tail(x {type-list:9:18}) {type-list:9:18}, y {type-list:9:26}) {type-list:9:18}) {type-list:9:10} {type-list:7:5}

 Module type-list
  public submods  : list
  public types    : 
  public resources: 
  public procs    : ++(x:list(t), y:list(t), ?$:?) <1>
  imports         : 
  types           : 
  resources       : 
  procs           : ++: [
proc ++(x:list(t), y:list(t), ?$:?) (id 1):  {type-list:6:8}
    [](?$tmp0) {type-list:7:13}
    ==(x, $tmp0, ?$tmp1) {type-list:7:8}
    case $tmp1 of {type-list:7:5}
      0:
        =(?$tmp6, y) {?}
      1:
        head(x, ?$tmp4) {type-list:9:11}
        tail(x, ?$tmp2) {type-list:9:18}
        ++($tmp2, y, ?$tmp3) {type-list:9:18}
        [|]($tmp4, $tmp3, ?$tmp5) {type-list:9:10}
        =(?$tmp6, $tmp5) {?}
    end
    =(?$, $tmp6) {?}]

Submodules of type-list:
list: 
 Module list(["t"])
  public submods  : 
  public types    : list/1
  public resources: 
  public procs    : [](?$:list(t)) <1>
                    [|](head:t, tail:list(t), ?$:list(t)) <2>
                    head(!$rec:list(t), $field:t) <4>
                    head($rec:list(t), ?$field:t) <3>
                    tail(!$rec:list(t), $field:list(t)) <6>
                    tail($rec:list(t), ?$field:list(t)) <5>
  imports         : 
  types           : list: arity 1  {type-list:1:8}
  resources       : 
  procs           : []: [
proc [](?$:list(t)) (id 1):  {?}
    $alloc([], ?$tmp0) {?}
    =(?$, $tmp0) {?}]
                    [|]: [
proc [|](head:t, tail:list(t), ?$:list(t)) (id 2):  {?}
    $alloc([|], ?$tmp1) {?}
    update$head(head, $tmp1, ?$tmp2) {?}
    update$tail(tail, $tmp2, ?$tmp3) {?}
    =(?$, $tmp3) {?}]
                    head: [
proc head(!$rec:list(t), $field:t) (id 4):  {?}
    foreign  mutate([|], !$rec, $field) {?},
proc head($rec:list(t), ?$field:t) (id 3):  {?}
    foreign  access([|], $rec, ?$field) {?}]
                    tail: [
proc tail(!$rec:list(t), $field:list(t)) (id 6):  {?}
    foreign  mutate([|], !$rec, $field) {?},
proc tail($rec:list(t), ?$field:list(t)) (id 5):  {?}
    foreign  access([|], $rec, ?$field) {?}]

Submodules of list:

