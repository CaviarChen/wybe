# The Wybe standard library (built-ins)

public type int is
    public func +(x:int,y:int):int = foreign llvm add(32,x,y)
    public proc +(?x:int,y:int,z:int) ?x = foreign llvm sub(32,z,y) end
    public proc +(x:int,?y:int,z:int) ?y = foreign llvm sub(32,z,x) end
    public func -(x:int,y:int):int = foreign llvm sub(32,x,y)
    public proc -(?x:int,y:int,z:int) ?x = foreign llvm add(32,z,y) end
    public proc -(x:int,?y:int,z:int) ?y = foreign llvm sub(32,z,x) end
    public func -(x:int):int = foreign llvm sub(32,0,x)
    public proc -(?x:int,y:int) ?x = foreign llvm sub(32,0,y) end
    public func *(x:int,y:int):int = foreign llvm mul(32,x,y)
    public func /(x:int,y:int):int = foreign llvm sdiv(32,x,y)
    public func ==(x:int,y:int):bool = foreign llvm icmp eq(32,x,y)
    public func /=(x:int,y:int):bool = foreign llvm icmp ne(32,x,y)
    public func <(x:int,y:int):bool = foreign llvm icmp slt(32,x,y)
    public func <=(x:int,y:int):bool = foreign llvm icmp sle(32,x,y)
    public func >(x:int,y:int):bool = foreign llvm icmp sgt(32,x,y)
    public func >=(x:int,y:int):bool = foreign llvm icmp sge(32,x,y)
    public proc =(?y:int, x:int) foreign llvm move(x, ?y) end
    public proc =(x:int, ?y:int) foreign llvm move(x, ?y) end
    public func =(x:int, y:int) = foreign llvm cmp eq(x, y)
    public func sqrt(x:int) = foreign C isqrt(x)
    public func power(x:int,y:int) = foreign C ipow(x,y)
end


public type float is
    public func +(x:float,y:float):float = foreign llvm fadd(64,x,y)
    public proc +(?x:float,y:float,z:float) ?x = foreign llvm fsub(64,z,y) end
    public proc +(x:float,?y:float,z:float) ?y = foreign llvm fsub(64,z,x) end
    public func -(x:float,y:float):float = foreign llvm fsub(64,x,y)
    public proc -(?x:float,y:float,z:float) ?x = foreign llvm fadd(64,z,y) end
    public proc -(x:float,?y:float,z:float) ?y = foreign llvm fsub(64,z,x) end
    public func -(x:float):float = foreign llvm sub(32,0,x)
    public proc -(?x:float,y:float) ?x = foreign llvm sub(32,0,y) end
    public func *(x:float,y:float):float = foreign llvm fmul(64,x,y)
    public func /(x:float,y:float):float = foreign llvm fdiv(64,x,y)
    public func ==(x:float,y:float):bool = foreign llvm fcmp eq(64,x,y)
    public func /=(x:float,y:float):bool = foreign llvm fcmp ne(64,x,y)
    public func <(x:float,y:float):bool = foreign llvm fcmp slt(64,x,y)
    public func <=(x:float,y:float):bool = foreign llvm fcmp sle(64,x,y)
    public func >(x:float,y:float):bool = foreign llvm fcmp sgt(64,x,y)
    public func >=(x:float,y:float):bool = foreign llvm fcmp sge(64,x,y)
    public proc =(?y:float, x:float) foreign llvm move(x, ?y) end
    public proc =(x:float, ?y:float) foreign llvm move(x, ?y) end
    public func =(x:float, y:float) = foreign llvm cmp eq(x, y)
    public func sqrt(x:float) = foreign C sqrt(x)
    public func power(x:float,y:float) = foreign C pow(x,y)
end


public type bool is
    public func true:bool = 1
    public func false:bool = 0
    # These are syntax errors because they are operators:
    # public func and(p:bool, q:bool):bool = foreign llvm and(p,q)
    # public func or(p:bool, q:bool):bool = foreign llvm or(p,q)
    # public func not(p:bool):bool = foreign xor(p,1)
    public proc =(?y:bool, x:bool) foreign llvm move(x, ?y) end
    public proc =(x:bool, ?y:bool) foreign llvm move(x, ?y) end
    public func =(x:bool, y:bool) = foreign llvm cmp eq(x, y)
    public func /=(x:bool,y:bool):bool = foreign llvm icmp ne(1,x,y)
end


public type string is
    # this implementation is completely wrong, but will do for now
    public func ++(x:string, y:string) = foreign c strcat(x,y)
    public proc =(?y:string, x:string) foreign llvm move(x, ?y) end
    public proc =(x:string, ?y:string) foreign llvm move(x, ?y) end
    public func =(x:string, y:string) = foreign llvm cmp eq(x, y)
    public func /=(x:string,y:string):bool = foreign c strcmp(x,y)
end


public type char is
    public proc =(?y:char, x:char) foreign llvm move(x, ?y) end
    public proc =(x:char, ?y:char) foreign llvm move(x, ?y) end
    public func =(x:char, y:char) = foreign llvm cmp eq(x, y)
    public func /=(x:char,y:char):bool = foreign llvm icmp ne(32,x,y)
end


public type int_seq is
    public ctor range(start:int, finish:int, incr:int)
    public proc [|](?next:int, ?rest:int_seq, curr:int_seq, ?succeed:bool)
    	# if curr.incr > 0 then
	#     ?succeed = curr.start > curr.finish
	# else
	#     ?succeed = curr.start < curr.finish
	# end
	# if succeeded then
	    ?next = curr.start
	    ?rest = sequence(curr.start+curr.incr, curr.finish, curr.incr)
	# end
    end
    public func empty(seq:int_seq) = true
end

public type list(t) is
    public ctor []
    public ctor [|](head:t, tail:list(t))
end

public func ++(x:list(t), y:list(t)) =
    if x == []
    then y
    else [x.head|x.tail++y]

public module io is
    public proc nl foreign c putc('\n') end

    public proc print(x:int) foreign c print_int(x) end
    public proc println(x:int) print(x) nl end
    public proc read(?x:int) foreign c read_int(?x) end

    public proc print(x:float) foreign c print_float(x) end
    public proc println(x:float) print(x) nl end
    public proc read(?x:float) foreign c read_float(?x) end

    public proc print(x:char) foreign c putchar(x) end
    public proc println(x:char) print(x) nl end
    public proc read(?x:char) foreign c read_char(?x) end

    public proc print(x:string) foreign c print_string(x) end
    public proc println(x:string) print(x) nl end
    public proc read(?x:string) foreign c read_line(?x) end

    public func eof:char = '.' # XXX completely wrong!!!
end
