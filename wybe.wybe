# The Wybe standard library (built-ins)

public type int is
    public func +(x:int,y:int):int = foreign llvm add(32,x,y)
    public proc +(?x:int,y:int,z:int) ?x = foreign llvm sub(32,z,y) end
    public proc +(x:int,?y:int,z:int) ?y = foreign llvm sub(32,z,x) end
    public func -(x:int,y:int):int = foreign llvm sub(32,x,y)
    public proc -(?x:int,y:int,z:int) ?x = foreign llvm add(32,z,y) end
    public proc -(x:int,?y:int,z:int) ?y = foreign llvm sub(32,z,x) end
    public func -(x:int):int = foreign llvm sub(32,0,x)
    public proc -(?x:int,y:int) ?x = foreign llvm sub(32,0,y) end
    public func *(x:int,y:int):int = foreign llvm mul(32,x,y)
    public func /(x:int,y:int):int = foreign llvm sdiv(32,x,y)
    public func /=(x:int,y:int):bool = foreign llvm icmp ne(32,x,y)
    public func <(x:int,y:int):bool = foreign llvm icmp slt(32,x,y)
    public func <=(x:int,y:int):bool = foreign llvm icmp sle(32,x,y)
    public func >(x:int,y:int):bool = foreign llvm icmp sgt(32,x,y)
    public func >=(x:int,y:int):bool = foreign llvm icmp sge(32,x,y)
    public func =(x:int, y:int):bool = foreign llvm icmp eq(32,x,y)
    public func sqrt(x:int):int = foreign C isqrt(x)
    public func power(x:int,y:int):int = foreign C ipow(x,y)
    public proc incr(!x:int) ?x = x + 1 end
    public proc decr(!x:int) ?x = x + 1 end
end


public type float is
    public func +(x:float,y:float):float = foreign llvm fadd(64,x,y)
    public proc +(?x:float,y:float,z:float) ?x = foreign llvm fsub(64,z,y) end
    public proc +(x:float,?y:float,z:float) ?y = foreign llvm fsub(64,z,x) end
    public func -(x:float,y:float):float = foreign llvm fsub(64,x,y)
    public proc -(?x:float,y:float,z:float) ?x = foreign llvm fadd(64,z,y) end
    public proc -(x:float,?y:float,z:float) ?y = foreign llvm fsub(64,z,x) end
    public func -(x:float):float = foreign llvm sub(32,0,x)
    public proc -(?x:float,y:float) ?x = foreign llvm sub(32,0,y) end
    public func *(x:float,y:float):float = foreign llvm fmul(64,x,y)
    public func /(x:float,y:float):float = foreign llvm fdiv(64,x,y)
    public func /=(x:float,y:float):bool = foreign llvm fcmp ne(64,x,y)
    public func <(x:float,y:float):bool = foreign llvm fcmp slt(64,x,y)
    public func <=(x:float,y:float):bool = foreign llvm fcmp sle(64,x,y)
    public func >(x:float,y:float):bool = foreign llvm fcmp sgt(64,x,y)
    public func >=(x:float,y:float):bool = foreign llvm fcmp sge(64,x,y)
    public func =(x:float, y:float):bool = foreign llvm fcmp eq(64,x,y)
    public func sqrt(x:float):float = foreign C sqrt(x)
    public func power(x:float,y:float):float = foreign C pow(x,y)
end


public type bool is
    public ctor false
    public ctor true
    # These are syntax errors because they are operators:
    public func and(p:bool, q:bool):bool = foreign llvm and(p,q)
    public func or(p:bool, q:bool):bool = foreign llvm or(p,q)
    public func not(p:bool):bool = foreign llvm xor(p,1)
    public func =(x:bool, y:bool):bool = foreign llvm icmp eq(1,x,y)
    public func /=(x:bool,y:bool):bool = foreign llvm icmp ne(1,x,y)
end


public type string is
    # this whole implementation is completely wrong, but will do for now
    public func ++(x:string, y:string):string = foreign c strcat(x,y)
    public func =(x:string, y:string):bool = foreign llvm icmp eq(64,x,y)
    public func /=(x:string,y:string):bool = foreign c strcmp(x,y)
end


public type char is
    public func =(x:char, y:char):bool = foreign llvm icmp eq(32,x,y)
    public func /=(x:char,y:char):bool = foreign llvm icmp ne(32,x,y)
end


public type int_seq is
    public ctor range(start:int, finish:int, incr:int)
    public proc [|](?next:int, ?rest:int_seq, curr:int_seq, ?succeed:bool)
    	# XXX commented out because it won't even parse!
    	# if curr.incr > 0 then
	#     ?succeed = curr.start > curr.finish
	# else
	#     ?succeed = curr.start < curr.finish
	# end
	?succeed = true
	# if succeed then
	    ?next = curr.start
	    ?rest = range(curr.start+curr.incr, curr.finish, curr.incr)
	# end
    end
    # this should just be []:
    public func empty(seq:int_seq):bool = true
end

# public type list(t) is
#     public ctor []
#     public ctor [|](head:t, tail:list(t))

#     public func ++(x:list(t), y:list(t)) =
#         if x = []
#         then y
#         else [x.head|x.tail++y]
#     public func =(x:list(t), y:list(t)) = false
# end

# public module io is
#     public resource io:phantom = phantom

#     public proc nl use !io foreign c putc('\n', !io) end

#     public proc print(x:int) use !io foreign c print_int(x,!io) end
#     public proc println(x:int) use !io print(x) nl end
#     public proc read(?x:int) use !io foreign c read_int(?x,!io) end

#     public proc print(x:float) use !io foreign c print_float(x,!io) end
#     public proc println(x:float) use !io print(x) nl end
#     public proc read(?x:float) use !io foreign c read_float(?x,!io) end

#     public proc print(x:char) use !io foreign c putchar(x,!io) end
#     public proc println(x:char) use !io print(x) nl end
#     public proc read(?x:char) use !io foreign c read_char(?x,!io) end

#     public proc print(x:string) use !io foreign c print_string(x,!io) end
#     public proc println(x:string) use !io print(x) nl end
#     public proc read(?x:string) use !io foreign c read_line(?x,!io) end

#     public func eof:char = '.' # XXX completely wrong!!!
# end
