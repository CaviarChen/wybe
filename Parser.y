{
--  File     : Parser.y
--  Author   : Peter Schachte
--  Origin   : Tue Nov 08 22:23:55 2011
--  Purpose  : Parser for the Wybe language
--  Copyright: Â© 2011-2012 Peter Schachte.  All rights reserved.

-- |The wybe parser (generated by happy).
module Parser (parse) where
import Scanner
import AST
-- import Text.ParserCombinators.Parsec.Pos
}

%name parse
%tokentype { Token }
%error { parseError }

%token 
      int             { TokInt _ _ }
      float           { TokFloat _ _ }
      char            { TokChar _ _ }
      dstring         { TokString DoubleQuote _ _ }
      bstring         { TokString BackQuote _ _ }
      '='             { TokSymbol "=" _ }
      '+'             { TokSymbol "+" _ }
      '-'             { TokSymbol "-" _ }
      '*'             { TokSymbol "*" _ }
      '/'             { TokSymbol "/" _ }
      '^'             { TokSymbol "^" _ }
      '++'            { TokSymbol "++" _ }
      '<'             { TokSymbol "<" _ }
      '>'             { TokSymbol ">" _ }
      '<='            { TokSymbol "<=" _ }
      '>='            { TokSymbol ">=" _ }
      '=='            { TokSymbol "==" _ }
      '/='            { TokSymbol "/=" _ }
      '|'             { TokSymbol "|" _ }
      '..'            { TokSymbol ".." _ }
-- If any other symbol tokens that can be used as funcs or procs are
-- defined here, they need to be added to the defintion of Symbol below
      ','             { TokComma _ }
      ';'             { TokSemicolon _ }
      ':'             { TokColon _ }
      '.'             { TokSymbol "." _ }
      '?'             { TokSymbol "?" _ }
      '!'             { TokSymbol "!" _ }
      'public'        { TokIdent "public" _ }
      'resource'      { TokIdent "resource" _ }
      'type'          { TokIdent "type" _ }
      'module'        { TokIdent "module" _ }
      'import'        { TokIdent "import" _ }
      'use'           { TokIdent "use" _ }
      'func'          { TokIdent "func" _ }
      'proc'          { TokIdent "proc" _ }
      'ctor'          { TokIdent "ctor" _ }
      'let'           { TokIdent "let" _ }
      'where'         { TokIdent "where" _ }
      'end'           { TokIdent "end" _ }
      'in'            { TokIdent "in" _ }
      'if'            { TokIdent "if" _ }
      'is'            { TokIdent "is" _ }
      'then'          { TokIdent "then" _ }
      'elseif'        { TokIdent "elseif" _ }
      'else'          { TokIdent "else" _ }
      'do'            { TokIdent "do" _ }
      'for'           { TokIdent "for" _ }
      'while'         { TokIdent "while" _ }
      'until'         { TokIdent "until" _ }
      'when'          { TokIdent "when" _ }
      'unless'        { TokIdent "unless" _ }
      'from'          { TokIdent "from" _ }
      'to'            { TokIdent "to" _ }
      'downto'        { TokIdent "downto" _ }
      'by'            { TokIdent "by" _ }
      'and'           { TokIdent "and" _ }
      'or'            { TokIdent "or" _ }
      'not'           { TokIdent "not" _ }
      'foreign'       { TokIdent "foreign" _ }
      'mod'           { TokIdent "mod" _ }
      ident           { TokIdent _ _ }
      '('             { TokLBracket Paren _ }
      ')'             { TokRBracket Paren _ }
      '['             { TokLBracket Bracket _ }
      ']'             { TokRBracket Bracket _ }
      '{'             { TokLBracket Brace _ }
      '}'             { TokRBracket Brace _ }
      symbol          { TokSymbol _ _ }


%nonassoc 'where' 'let'
%left 'or'
%left 'and'
%left 'not'
%nonassoc 'in' '==' '/='
%left '>' '<' '<=' '>='
%nonassoc 'by'
%nonassoc '..'
%right '++'
%left '+' '-'
%left '*' '/' 'mod'
%left '^'
%left NEG
%left '.'
%%

Items :: { [Item] }
    : RevItems                  { reverse $1 }

RevItems :: { [Item] }
    : {- empty -}               { [] }
    | RevItems Item             { $2:$1 }


Item  :: { Item }
    : Visibility 'type' TypeProto 'is' Items 'end'
                                { TypeDecl $1 $3 $5 $ 
				    Just $ tokenPosition $2 }
    | Visibility 'module' ident 'is' Items 'end'
                                { ModuleDecl $1 (identName $3) $5 $ 
				    Just $ tokenPosition $2 }
    | Visibility ImportType ModSpecs
                                { ImportMods $1 (content $2) $3 $ place $2 }
    | Visibility 'from' ModSpec ImportType Idents
                                { ImportItems $1 (content $4) $3 $5 $ 
				    Just $ tokenPosition $2 }
    | Visibility 'resource' ident OptType
                                { ResourceDecl $1 (identName $3) $4
				    $ Just $ tokenPosition $2 }
    | Visibility 'func' FnProto OptType '=' Exp
                                { FuncDecl $1 $3 $4 $6
				    $ Just $ tokenPosition $2 }
    | Visibility 'proc' ProcProto ProcBody
                                { ProcDecl $1 $3 $4 $ Just $ tokenPosition $2 }
    | Visibility 'ctor' FnProto { CtorDecl $1 $3
				    $ Just $ tokenPosition $2 }
    | Stmt                      { StmtDecl (content $1) (place $1) }


TypeProto :: { TypeProto }
    : ident OptIdents           { TypeProto (identName $1) $2 }

Ctors :: { [FnProto] }
    : RevCtors                  { reverse $1 }

RevCtors :: { [FnProto] }
    : FnProto                   { [$1] }
    | RevCtors FnProto          { $2:$1 }

ImportType :: { Placed Bool }
    : 'import'                  { Placed True (tokenPosition $1) }
    | 'use'                     { Placed False (tokenPosition $1) }

ModSpecs :: { [ModSpec] }
    : ModSpec RevModSpecList
                                { $1 : reverse $2 }
RevModSpecList :: { [ModSpec] }
    : {- empty -}               { [] }
    | RevModSpecList ',' ModSpec
                                { $3:$1 }

ModSpec :: { ModSpec }
    : ident RevModuleTail       { identName $1:reverse $2 }

RevModuleTail :: { ModSpec }
    : {- empty -}               { [] }
    | RevModuleTail '.' ident   { identName $3:$1}

FnProto :: { FnProto }
    : FuncProcName OptParamList { FnProto $1 $2 }

FuncProcName :: { String }
    : ident                     { identName $1 }
    | Symbol                    { symbolName $1 }


Symbol :: { Token }
    : '='                       { $1 }
    | '+'                       { $1 }
    | '-'                       { $1 }
    | '*'                       { $1 }
    | '/'                       { $1 }
    | '++'                      { $1 }
    | '<'                       { $1 }
    | '>'                       { $1 }
    | '<='                      { $1 }
    | '>='                      { $1 }
    | '=='                      { $1 }
    | '/='                      { $1 }
    | '|'                       { $1 }
-- XXX this doesn't work:
--    | '..'                      { $1 }
    | '[' ']'                   { TokSymbol "[]"  (tokenPosition $1) }
    | '[' '|' ']'               { TokSymbol "[|]" (tokenPosition $1) }
    | '{' '}'                   { TokSymbol "{}"  (tokenPosition $1) }
    | symbol                    { $1 }


ProcProto :: { ProcProto }
    : FuncProcName OptProcParamList
                                { ProcProto $1 $2 }

OptParamList :: { [Param] }
    : {- empty -}               { [] }
    | '(' Params ')'            { $2 }

Params :: { [Param] }
    : RevParams                 { reverse $1 }

RevParams :: { [Param] }
    : Param                     { [$1] }
    | RevParams ',' Param       { $3 : $1 }

Param :: { Param }
    : ident OptType             { Param (identName $1) $2 ParamIn }

OptProcParamList :: { [Param] }
    : {- empty -}               { [] }
    | '(' ProcParams ')'        { $2 }

ProcParams :: { [Param] }
    : RevProcParams             { reverse $1 }

RevProcParams :: { [Param] }
    : ProcParam                 { [$1] }
    | RevProcParams ',' ProcParam
                                { $3 : $1 }

ProcParam :: { Param }
    : FlowDirection ident OptType
                                { Param (identName $2) $3 $1 }

FlowDirection :: { FlowDirection }
    : {- empty -}               { ParamIn }
    | '?'                       { ParamOut }
    | '!'                       { ParamInOut }

OptType :: { TypeSpec }
    : {- empty -}               { Unspecified }
    | ':' Type                  { $2 }


Type :: { TypeSpec }
    : ident OptTypeList         { TypeSpec (identName $1) $2 }

OptTypeList :: { [TypeSpec] }
    : {- empty -}               { [] }
    | '(' Types ')'             { $2 }

Types :: { [TypeSpec] }
    : RevTypes                  { reverse $1 }

RevTypes :: { [TypeSpec] }
    : Type                      { [$1] }
    | RevTypes ',' Type         { $3 : $1 }


OptIdents :: { [String] }
    : {- empty -}               { [] }
    | '(' Idents ')'            { $2 }

Idents :: { [String] }
    : RevIdents                 { reverse $1 }

RevIdents :: { [String] }
    : ident                     { [identName $1] }
    | RevIdents ',' ident       { (identName $3):$1 }

Visibility :: { Visibility }
    : {- empty -}               { Private }
    | 'public'                  { Public }

ProcBody :: { [Placed Stmt] }
    : Stmts 'end'               { $1 }

Stmts :: { [Placed Stmt] }
    : RevStmts                  { reverse $1 }

RevStmts :: { [Placed Stmt] }
    : {- empty -}               { [] }
    | RevStmts Stmt             { $2:$1 }

Stmt :: { Placed Stmt }
    : Exp                       { maybePlace (expToStmt $ content $1) 
	                          (place $1) }
    | 'if' Stmt 'then' Stmts Condelse 'end'
                                { Placed (Cond [$2] $4 $5)
                                 (tokenPosition $1) }
    | 'do' Stmts 'end'          { Placed (Loop $2)
                                  (tokenPosition $1) }
    | 'for' Exp 'in' Exp        { Placed (For $2 $4)
                                  (tokenPosition $1) }
    | 'until' Stmt              { Placed (Cond [$2] [Unplaced $ Break]
                                                  [Unplaced $ Nop])
                                  (tokenPosition $1) }
    | 'while' Stmt              { Placed (Cond [$2] [Unplaced $ Nop]
                                                  [Unplaced $ Break])
                                  (tokenPosition $1) }
    | 'unless' Stmt             { Placed (Cond [$2] [Unplaced $ Nop]
                                                  [Unplaced $ Next])
                                         (tokenPosition $1) }
    | 'when' Stmt               { Placed (Cond [$2] [Unplaced $ Next]
					          [Unplaced $ Nop])
                                         (tokenPosition $1) }

OptProcArgs :: { [Placed Exp] }
    : {- empty -}               { [] }
    | '(' ProcArg ProcArgList ')'
                                { $2:$3 }

ProcArgList :: { [Placed Exp] }
    : RevProcArgList            { reverse $1 }

RevProcArgList :: { [Placed Exp] }
    : {- empty -}               { [] }
    | RevProcArgList ',' ProcArg
                                { $3:$1 }

ProcArg :: { Placed Exp }
    : Exp         { ($1) }

Condelse :: { [Placed Stmt] }
    : 'else' Stmts              { $2 }
    | {- empty -}               { [] }


-- Generator :: { Generator }
--     : ident 'in' Exp            { In (identName $1) $3 }
--     | ident 'from' Exp toLimit byStep
--                                 { InRange (identName $1) $3 
-- 				    (fst $4) $5 (snd $4) }
-- 
-- byStep :: { Placed Exp }
--     : 'by' Exp                  { $2 }
--     | {- empty -}               { Unplaced $ IntValue 1 }
-- 
-- toLimit :: { (ProcName, Maybe (String,Placed Exp)) }
--     : 'to' Exp                  { ("+", Just (">", $2)) }
--     | 'downto' Exp              { ("-", Just ("<", $2)) }
--     | {- empty -}               { ("+", Nothing) }


SimpleExp :: { Placed Exp }
    : Exp '+' Exp               { maybePlace (Fncall Nothing (symbolName $2)
                                              [$1, $3])
	                                     (place $1) }
    | Exp '-' Exp               { maybePlace (Fncall Nothing (symbolName $2)
                                              [$1, $3])
                                             (place $1) }
    | Exp '*' Exp               { maybePlace (Fncall Nothing (symbolName $2)
                                              [$1, $3])
                                             (place $1) }
    | Exp '/' Exp               { maybePlace (Fncall Nothing (symbolName $2)
                                              [$1, $3])
                                             (place $1) }
    | Exp 'mod' Exp             { maybePlace (Fncall Nothing (identName $2)
                                              [$1, $3])
                                             (place $1) }
    | Exp '^' Exp               { maybePlace (Fncall Nothing (symbolName $2)
                                              [$1, $3])
                                             (place $1) }
    | Exp '++' Exp              { maybePlace (Fncall Nothing (symbolName $2)
                                              [$1, $3])
                                             (place $1) }
    | Exp '<' Exp               { maybePlace (Fncall Nothing (symbolName $2)
                                              [$1, $3])
                                             (place $1) }
    | Exp '<=' Exp              { maybePlace (Fncall Nothing (symbolName $2)
                                              [$1, $3])
                                             (place $1) }
    | Exp '>' Exp               { maybePlace (Fncall Nothing (symbolName $2)
                                              [$1, $3])
                                             (place $1) }
    | Exp '>=' Exp              { maybePlace (Fncall Nothing (symbolName $2)
                                              [$1, $3])
                                             (place $1) }
    | Exp '==' Exp              { maybePlace (Fncall Nothing (symbolName $2)
                                              [$1, $3])
                                             (place $1) }
    | Exp '=' Exp               { maybePlace (Fncall Nothing (symbolName $2)
                                              [$1, $3])
                                             (place $1) }
    | Exp '/=' Exp              { maybePlace (Fncall Nothing (symbolName $2)
                                              [$1, $3])
                                             (place $1) }
    | 'not' Exp                 { Placed (Fncall Nothing (identName $1) [$2])
	                                 (tokenPosition $1) }
    | Exp 'and' Exp             { maybePlace (Fncall Nothing (identName $2)
                                              [$1, $3])
	                                     (place $1) }
    | Exp 'or' Exp              { maybePlace (Fncall Nothing (identName $2)
                                              [$1, $3])
                                             (place $1) }
    | Exp '..' Exp              { maybePlace (Fncall Nothing (symbolName $2) 
					      [$1, $3, Unplaced $ IntValue 1])
                                             (place $1) }
    | '(' Exp ')'               { Placed (content $2) (tokenPosition $1) }
    | '-' Exp %prec NEG         { Placed (Fncall Nothing "Negate" [$2])
	                                 (tokenPosition $1) }
    | int                       { Placed (IntValue $ intValue $1)
	                                 (tokenPosition $1) }
    | float                     { Placed (FloatValue $ floatValue $1)
	                                 (tokenPosition $1) }
    | char                      { Placed (CharValue $ charValue $1)
	                                 (tokenPosition $1) }
    | dstring                   { Placed (StringValue $ stringValue $1)
	                                 (tokenPosition $1) }
    | bstring                   { Placed (StringValue $ stringValue $1)
	                                 (tokenPosition $1) }
    | ident                     { Placed (Var (identName $1) ParamIn)
	                                 (tokenPosition $1) }
    | '?' ident                 { Placed (Var (identName $2) ParamOut)
	                                 (tokenPosition $1) }
    | '!' ident                 { Placed (Var (identName $2) ParamInOut)
	                                 (tokenPosition $1) }
    | ident ArgList             { Placed (Fncall Nothing (identName $1) $2)
	                                 (tokenPosition $1) }
    | symbol ArgList            { Placed (Fncall Nothing (symbolName $1) $2)
	                                 (tokenPosition $1) }
    | Exp '.' ident             { maybePlace (Fncall Nothing (identName $3) [$1])
	                                     (place $1) }
    | Exp '.' ident ArgList     { maybePlace (Fncall Nothing (identName $3) ($1:$4))
	                                     (place $1) }
    | 'foreign' ident ident ArgList
                                { Placed (ForeignFn (identName $2)
					  (identName $3) $4)
                                         (tokenPosition $1) }
    | '[' ']'                   { Placed (Fncall Nothing "[]" [])
	                                 (tokenPosition $1) }
    | '[' Exp ListTail          { Placed (Fncall Nothing "[|]" [$2, $3])
	                                 (tokenPosition $1) }
    | '{' '}'                   { Placed (Fncall Nothing "{}" [])
	                                 (tokenPosition $1) }

Exp :: { Placed Exp }
    : 'if' Stmt 'then' Exp 'else' Exp
                                { Placed (CondExp [$2] $4 $6)
				         (tokenPosition $1) }
    | 'let' Stmts 'in' Exp      { Placed (Where $2 $4) (tokenPosition $1) }
    | Exp 'where' ProcBody      { maybePlace (Where $3 $1) (place $1) }
    | SimpleExp                 { $1 }


ListTail :: { Placed Exp }
    : ']'                       { Unplaced (Fncall Nothing "[]" []) }
    | ',' Exp ListTail          { Unplaced (Fncall Nothing "[|]" [$2,$3]) }
    | '|' Exp ']'               { $2 }


ArgList :: { [Placed Exp] }
    : '(' Exp ExpList ')'       { $2:$3 }

ExpList :: { [Placed Exp] }
    : RevExpList                { reverse $1 }

RevExpList :: { [Placed Exp] }
    : {- empty -}               { [] }
    | RevExpList ',' Exp        { $3:$1 }

{
parseError :: [Token] -> a
parseError [] = error $ "Parse error at end of file"
parseError (tok:_) = error $ (showPosition (tokenPosition tok)) 
                             ++ ": Parse error"
}
